<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>blog折腾记录</title>
    <url>/2021/12/17/blog%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近开始重拾写blog的习惯，想着坚持点啥吧。</p>
<p>结果将github上的网站打开，2020-03最近一篇，现在可是2021-12月了，搁置了1年9个月，真行。</p>
<p>然后打算上传一篇blog，发现新电脑上环境也没有了。大脑开始告诉运转，好吧~ 完全没有一点映像。</p>
<p>因此，打算乖乖的写文章记录，好记性不如烂笔头，先人们不曾欺我啊~</p>
<h4 id="操作记录"><a href="#操作记录" class="headerlink" title="操作记录"></a>操作记录</h4><p>之前还折腾什么mweb，一键部署多个平台啥的。现在可能是思想观念变了，内容平台还是以内容为主。既然都花了那么多心思写了，难道还不能去各个平台溜达一圈部署下。</p>
<h5 id="用什么写？"><a href="#用什么写？" class="headerlink" title="用什么写？"></a>用什么写？</h5><blockquote>
<p>Typero</p>
</blockquote>
<h5 id="用什么图床？"><a href="#用什么图床？" class="headerlink" title="用什么图床？"></a>用什么图床？</h5><blockquote>
<p> 路过图床。就是觉得剪贴板直接ctrl+v很方便，懒得换。</p>
</blockquote>
<h5 id="发布到哪"><a href="#发布到哪" class="headerlink" title="发布到哪"></a>发布到哪</h5><p>原则就是支持MD导入</p>
<ul>
<li>github，可以去百度智能云上去申请一个域名，便宜的一年就13元，不过续费比较贵☺️。</li>
<li>csdn</li>
<li>cnblog(不支持MD导入，有点愁人)</li>
<li>简书(不支持MD导入，放弃)</li>
</ul>
<h5 id="hexo与github配置"><a href="#hexo与github配置" class="headerlink" title="hexo与github配置"></a>hexo与github配置</h5><p>说起来我之前弄过一版，但是完成忘记了。更惨的是git仓库的东西都不知道怎么复用，只能完全重来，就当是一个新的开始好了。</p>
<p>先将一次性的操作做了，安装&amp;配置。配置文件只有2个，一定要做好备份</p>
<p>_config.yml: 网站配置</p>
<p>themes/next/_config.yml：主题配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mac上安装hexo</span></span><br><span class="line">brew install hexo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化项目</span></span><br><span class="line">hexo init myblog</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> next主题</span></span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定制化配置 _config.yml</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># site： 这力的language要和主题里面的themes/next/languages下面的文件能对应才行</span></span></span><br><span class="line">title: Moonshine&#x27;s Blog</span><br><span class="line">subtitle: &#x27;日拱一卒无有尽，功不唐捐终入海&#x27;</span><br><span class="line">description: &#x27;風が吹いて葉が落ち、落ち葉は土壌の肥やしとなり土壌を肥えさせ、果物がゆっくりと着実に育つのです&#x27;</span><br><span class="line">keywords: &#x27;数据库&#x27;</span><br><span class="line">author: Moonshine</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># url</span></span></span><br><span class="line">url: https://zhangtinglu.github.io/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 主题</span></span></span><br><span class="line">theme: next</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 部署git</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repo: &#x27;https://github.com/zhangtinglu/zhangtinglu.github.io&#x27;</span><br><span class="line">  branch: &#x27;master&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 代码语法高亮，将prismjs改成true就行了</span></span></span><br><span class="line">prismjs:</span><br><span class="line">  enable: true </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定制theme配置 themes/next/_config.yml -- 有点多，直接备份吧</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把自己需要的需要的page安装下</span></span><br><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 首页摘要 -- 太费劲了，直接用归档页面当成主页</span></span><br><span class="line">~/myblog/themes/next/layout </span><br><span class="line">mv index.swig index_bak.swig</span><br><span class="line">cp archive.swig index.swig</span><br><span class="line"><span class="meta">#</span><span class="bash"> 代码可折叠 - 收缩</span></span><br><span class="line">codeblock:</span><br><span class="line">	highlight_theme: night</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显得太大了 -- 不管能看就行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文章目录</span></span><br><span class="line">toc:</span><br><span class="line">	expand_all: true</span><br></pre></td></tr></table></figure>

<p>接着就是平常使用了，创建blog-deploy</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先将hello world这个page删除</span></span><br><span class="line">rm -rf /source/_posts/hello-world.md</span><br><span class="line">hexo new &#x27;blog&#x27;</span><br><span class="line">hexo s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署</span></span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>hexo配置</tag>
      </tags>
  </entry>
  <entry>
    <title>hashicorp:raft源码系列(3)--存储层</title>
    <url>/2021/12/17/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-3-%E5%AD%98%E5%82%A8%E5%B1%82/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>接着上一篇我们讲了网络层，接下来我们来讲LogStore、StableStore、FSM、SnapshotStore，为啥这些一起讲呢，因为这些都是存储相关，并且功能相对简单，并没有像Transport那样有NetworkTransport实现可以用来进行分析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(conf *Config, fsm FSM, logs LogStore, stable StableStore, snaps SnapshotStore, trans Transport)</span> <span class="params">(*Raft, error)</span></span> &#123;     	......&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StableStore"><a href="#StableStore" class="headerlink" title="StableStore"></a>StableStore</h4><p>这个组件主要就是为了安全考虑而存在的，提供一个可以持久化k-v的存储的即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StableStore <span class="keyword">interface</span> &#123;</span><br><span class="line">	Set(key []<span class="keyword">byte</span>, val []<span class="keyword">byte</span>) error</span><br><span class="line">	Get(key []<span class="keyword">byte</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uint64是日志号和任期定义的类型，方便存</span></span><br><span class="line">	SetUint64(key []<span class="keyword">byte</span>, val <span class="keyword">uint64</span>) error</span><br><span class="line">	GetUint64(key []<span class="keyword">byte</span>) (<span class="keyword">uint64</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="LogStore"><a href="#LogStore" class="headerlink" title="LogStore"></a>LogStore</h4><p>这个组件就是为了存日志的，比如用户发过来set a=1, 将这个存起来即可。和上面的StableStore能力是同一种，不过日志可能比较多，需要根据实现情况进行选择。项目在测试的时候实现了一个inmem的日志存储，用了一个map来进行存储。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inmem模拟，直接map存，基本能力-读写。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInmemStore</span><span class="params">()</span> *<span class="title">InmemStore</span></span> &#123;</span><br><span class="line">	i := &amp;InmemStore&#123;</span><br><span class="line">		logs:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint64</span>]*Log),</span><br><span class="line">		kv:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>),</span><br><span class="line">		kvInt: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="FSM"><a href="#FSM" class="headerlink" title="FSM"></a>FSM</h4><p>FMS的功能，其实②+③有点没要，不是Raft的核心逻辑。Raft启动时候会有一个后台协程runFSM负责来做下面的三件事，Main线程将应用日志请求放到fsmMutateCh里面，将打快照的请求放到fsmSnapshotCh里面，不阻塞Main</p>
<p>① 应用日志，raft log多数派已经确认，就可以应用到底层存储了。</p>
<p>② 快照</p>
<p>③ 节点恢复</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FSM <span class="keyword">interface</span> &#123;</span><br><span class="line">	Apply(*Log) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Snapshot() (FSMSnapshot, error)</span><br><span class="line">	Restore(io.ReadCloser) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">runFSM</span><span class="params">()</span></span> &#123;</span><br><span class="line">  commitSingle := <span class="function"><span class="keyword">func</span><span class="params">(req *commitTuple)</span></span></span><br><span class="line">  commitBatch := <span class="function"><span class="keyword">func</span><span class="params">(reqs []*commitTuple)</span></span></span><br><span class="line">  restore := <span class="function"><span class="keyword">func</span><span class="params">(req *restoreFuture)</span></span> </span><br><span class="line">  snapshot := <span class="function"><span class="keyword">func</span><span class="params">(req *reqSnapshotFuture)</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> ptr := &lt;-r.fsmMutateCh:</span><br><span class="line">			<span class="keyword">switch</span> req := ptr.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> []*commitTuple:</span><br><span class="line">				commitBatch(req)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> *restoreFuture:</span><br><span class="line">				restore(req)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;bad type passed to fsmMutateCh: %#v&quot;</span>, ptr))</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> req := &lt;-r.fsmSnapshotCh:</span><br><span class="line">			snapshot(req)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-r.shutdownCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>hashicorp:raft源码系列(2)--网络层</title>
    <url>/2021/12/17/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-2-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>接着上面–导读，本篇讲解Transport传输层实现。</p>
<p>如下NewRaft函数的参数中，除了Config结构，其他都是以interface形式实现。</p>
<p>接下来几篇我们分别对这5类接口进行详细分析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(conf *Config, fsm FSM, logs LogStore, stable StableStore, snaps SnapshotStore, trans Transport)</span> <span class="params">(*Raft, error)</span></span> &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="传输层涉及哪些文件"><a href="#传输层涉及哪些文件" class="headerlink" title="传输层涉及哪些文件"></a>传输层涉及哪些文件</h4><ul>
<li><p>transport.go: 定义传输层接口，下图中的Transport Interface对象。</p>
</li>
<li><p>inmem_transport.go: 以内存的方式实现Transport接口，用于测试。</p>
</li>
<li><p>net_transport.go: 网络方式实现Transport接口。</p>
</li>
<li><p>tcp_transport.go: 以TCP的方式实现了NetworkTransport需要的SteamLayer。</p>
</li>
<li><p>command.go：这个文件里面定义了各种RPC request和response的结构，eg: AppendEntriesRequest、AppendEntriesResponse</p>
<p><a href="https://imgtu.com/i/ovlYo6"><img src="https://s4.ax1x.com/2021/12/14/ovlYo6.png" alt="ovlYo6.png"></a></p>
</li>
</ul>
<p>总结，NetworkTransport和InmemTransport是对Transport层的具体实现，接下来我们对NetworkTransport进行详细分析。</p>
<h4 id="传输层具体是怎么实现的呢？"><a href="#传输层具体是怎么实现的呢？" class="headerlink" title="传输层具体是怎么实现的呢？"></a>传输层具体是怎么实现的呢？</h4><h5 id="从测试用例TestNetworkTransport-AppendEntries开始"><a href="#从测试用例TestNetworkTransport-AppendEntries开始" class="headerlink" title="从测试用例TestNetworkTransport_AppendEntries开始"></a>从测试用例TestNetworkTransport_AppendEntries开始</h5><p>测试用例一般能告诉我们怎么玩，而AppendEntries发送日志又是最常用的功能。因此，我们就从这里开始。</p>
<p><a href="https://imgtu.com/i/ovW3X4"><img src="https://s4.ax1x.com/2021/12/14/ovW3X4.md.png" alt="ovW3X4.md.png"></a></p>
<ol>
<li><p>初始化消费者(trans1)，这一步后面是要详细看的，所以我们标星。</p>
</li>
<li><p>启动消费者，监听rpcCh，也就是Consumer()返回的只读channel。🤔：rpc.Respond函数只是给respCh添加了一个元素，那谁来消费这个元素呢？</p>
</li>
<li><p>初始化生产者( trans2)，同样使用newTCPTransport实现。</p>
</li>
<li><p>调用AppendEntries消息给消费者trans1，这里直接就获取返回了。为啥看着就是同步返回的呢? 按理说网络调用一般都是异步返回吧。这个星标步骤，我们后面来详细分析。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNetworkTransport_AppendEntries</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, useAddrProvider := <span class="keyword">range</span> []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>&#125; &#123;</span><br><span class="line">		<span class="comment">// ①初始化trans1 -- 消费者</span></span><br><span class="line">		trans1, err := makeTransport(t, useAddrProvider, <span class="string">&quot;localhost:0&quot;</span>)</span><br><span class="line">		</span><br><span class="line">		rpcCh := trans1.Consumer()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 定义测试使用的RPC请求</span></span><br><span class="line">		args := AppendEntriesRequest&#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		resp := AppendEntriesResponse&#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ② 启动消费者监听 </span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> rpc := &lt;-rpcCh:</span><br><span class="line">				<span class="comment">// 获取消息然后返回，注意Respond函数只是给RPC对象的RespChan添加一个值，那么谁来消费这和chan呢</span></span><br><span class="line">				rpc.Respond(&amp;resp, <span class="literal">nil</span>)</span><br><span class="line">			...</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ③ 初始化生产者 trans2</span></span><br><span class="line">		trans2, err := makeTransport(t, useAddrProvider, <span class="keyword">string</span>(trans1.LocalAddr()))</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ④ 发送AppendEntries消息给trans1，这里直接就获取返回了。为啥看着就是同步返回的呢</span></span><br><span class="line">		<span class="keyword">if</span> err := trans2.AppendEntries(<span class="string">&quot;id1&quot;</span>, trans1.LocalAddr(), &amp;args, &amp;out); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.Fatalf(<span class="string">&quot;err: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="makeTransport实现分析"><a href="#makeTransport实现分析" class="headerlink" title="makeTransport实现分析"></a>makeTransport实现分析</h5><ol>
<li><p>先看下函数调用关系</p>
<p>newTCPTransport：就是tcp端口绑定，生成TCPStreamLayer(上面的类图中知道是NetworkTransport结构需要的成员)</p>
<p>NewNetworkTransportWithConfig：创建NetworkTransport对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   makeTransport</span><br><span class="line">   -&gt; NewTCPTransportWithConfig</span><br><span class="line">     -&gt; newTCPTransport <span class="comment">// 负责进行tcp端口绑定，生成TCPStreamLayer</span></span><br><span class="line">   		-&gt; NewNetworkTransportWithConfig <span class="comment">// 真正创建NetworkTransport对象</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> newTCPTransport</span><br><span class="line"></span><br><span class="line">   下面是newTCPTransport的实现，最后transportCreator就是网络层的创建器</span><br><span class="line"></span><br><span class="line">   <span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">   // ① 调用net库绑定tcp监听端口</span></span><br><span class="line"><span class="string">   list, err := net.Listen(&quot;tcp&quot;, bindAddr)</span></span><br><span class="line"><span class="string">   // ② 将TCPListener -&gt; TCPStreamLayer(上面的类图中NetworkTransport需要实现StreamLayer接口)</span></span><br><span class="line"><span class="string">   stream := &amp;TCPStreamLayer&#123;</span></span><br><span class="line"><span class="string">   		advertise: advertise,</span></span><br><span class="line"><span class="string">   		listener:  list.(*net.TCPListener),</span></span><br><span class="line"><span class="string">   	&#125;</span></span><br><span class="line"><span class="string">   // ③ 将上面的 TCPStreamLayer-&gt; NetworkTransport，调用 NewNetworkTransportWithConfig</span></span><br><span class="line"><span class="string">   trans := transportCreator(stream)</span></span><br></pre></td></tr></table></figure></li>
<li><p>newNetworkTransport</p>
<p>下面是创建网络层的代码，一个Acceptor专门用来accetor连接，每个新的连接都会创建一个协程进行处理。</p>
<p><a href="https://imgtu.com/i/T9BOV1"><img src="https://s4.ax1x.com/2021/12/16/T9BOV1.png" alt="T9BOV1.png"></a></p>
<ul>
<li><p>Main线程调用trans.listen()启动监听协程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ① 将上面的config注入进来，主要是Stream</span></span><br><span class="line">trans := &amp;NetworkTransport&#123;</span><br><span class="line">		connPool:              <span class="built_in">make</span>(<span class="keyword">map</span>[ServerAddress][]*netConn),</span><br><span class="line">		consumeCh:             <span class="built_in">make</span>(<span class="keyword">chan</span> RPC),</span><br><span class="line">		logger:                config.Logger,</span><br><span class="line">		maxPool:               config.MaxPool,</span><br><span class="line">		shutdownCh:            <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		stream:                config.Stream,</span><br><span class="line">		timeout:               config.Timeout,</span><br><span class="line">		TimeoutScale:          DefaultTimeoutScale,</span><br><span class="line">		serverAddressProvider: config.ServerAddressProvider,</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// ② 设置Stream上下文</span></span><br><span class="line">trans.setupStreamContext()</span><br><span class="line"><span class="comment">// ③ 启动一个后台线程，专门来处理连接</span></span><br><span class="line"><span class="keyword">go</span> trans.listen()</span><br></pre></td></tr></table></figure></li>
<li><p>Acceptor监听新连接，并启动处理协程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">listen</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// ① 接收新连接，这个底层是epoll实现，</span></span><br><span class="line">		conn, err := n.stream.Accept()</span><br><span class="line">		<span class="comment">// ② 启动处理协程</span></span><br><span class="line">		<span class="keyword">go</span> n.handleConn(n.getStreamContext(), conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对连接进行处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">handleConn</span><span class="params">(connCtx context.Context, conn net.Conn)</span></span> &#123;</span><br><span class="line">	r := bufio.NewReaderSize(conn, connReceiveBufferSize)</span><br><span class="line">	w := bufio.NewWriter(conn)</span><br><span class="line">	dec := codec.NewDecoder(r, &amp;codec.MsgpackHandle&#123;&#125;)</span><br><span class="line">	enc := codec.NewEncoder(w, &amp;codec.MsgpackHandle&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ① 读数据 -- 解码 -- 处理 -- 编码</span></span><br><span class="line">		<span class="keyword">if</span> err := n.handleCommand(r, dec, enc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// ② 返回</span></span><br><span class="line">		<span class="keyword">if</span> err := w.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handleCommand是核心的处理逻辑，这里通过chan让用户使用的时候感觉是同步的。</p>
<ol>
<li><p>获取类型ReadByte，约定第一位表示的RPC类型，eg:AppendEntries RequestVote</p>
</li>
<li><p>定义respCh。</p>
</li>
<li><p>对不同类型的Request进行解码。</p>
</li>
<li><p>将解码出来的RPC消息放到消费channel中</p>
</li>
<li><p>等respCh返回处理后的结构</p>
</li>
<li><p>将结构进行编码。</p>
<p>下面是和别的协程进行交互的方式，实际上处理逻辑是外包出去进行处理的。</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/T9R9Hg"><img src="https://s4.ax1x.com/2021/12/16/T9R9Hg.png" alt="T9R9Hg.png"></a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">handleCommand</span><span class="params">(r *bufio.Reader, dec *codec.Decoder, enc *codec.Encoder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	getTypeStart := time.Now()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ① 获取类型，约定第一位表示的RPC类型，eg:AppendEntries RequestVote</span></span><br><span class="line">	rpcType, err := r.ReadByte()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ② 定义respCh</span></span><br><span class="line">	respCh := <span class="built_in">make</span>(<span class="keyword">chan</span> RPCResponse, <span class="number">1</span>)</span><br><span class="line">	rpc := RPC&#123;</span><br><span class="line">		RespChan: respCh,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ③ 对不同类型的Request进行解码</span></span><br><span class="line">	<span class="keyword">switch</span> rpcType &#123;</span><br><span class="line">	<span class="keyword">case</span> rpcAppendEntries:</span><br><span class="line">		<span class="keyword">var</span> req AppendEntriesRequest</span><br><span class="line">		<span class="keyword">if</span> err := dec.Decode(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		rpc.Command = &amp;req</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> rpcRequestVote:</span><br><span class="line">		<span class="keyword">var</span> req RequestVoteRequest</span><br><span class="line">		<span class="keyword">if</span> err := dec.Decode(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		rpc.Command = &amp;req</span><br><span class="line">   ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ④ 将解码出来的灌到Raft.consumeCh</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> n.consumeCh &lt;- rpc:</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ⑤ 等结果，上面的consumeCh被Raft的runLeader之类的其他协程进行处理后，将结果塞会到respCh。</span></span><br><span class="line">RESP:</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> resp := &lt;-respCh:</span><br><span class="line">		<span class="comment">// ⑥ 对结果进行编码</span></span><br><span class="line">		<span class="keyword">if</span> err := enc.Encode(resp.Response); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="AppendEntries实现分析"><a href="#AppendEntries实现分析" class="headerlink" title="AppendEntries实现分析"></a>AppendEntries实现分析</h5><p>上面的传输层已经创建好了连接的处理器(消费者)，现在需要消息的生产者，AppendEntries就能充当这一角色。</p>
<p>需要网络交互的RequestVote、AppendEntries、TimeoutNow都是调用的genericRPC实现的，genericRPC是真正执行请求的函数。</p>
<p><a href="https://imgtu.com/i/ovxupF"><img src="https://s4.ax1x.com/2021/12/14/ovxupF.png" alt="ovxupF.png"></a></p>
<p>下面是一个genericRPC的流程：</p>
<p>① 从连接池获取连接对象，简单的维护了一个连接池。</p>
<p>② 在连接上发送RPC请求。</p>
<p>③ 解码Response，将conn返还连接池如果可以的话。</p>
<blockquote>
<p>注意：这里发送请求之后，同步获取Response。如果是短链接，为了高效就不会直接在这里等结果了。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">genericRPC</span><span class="params">(id ServerID, target ServerAddress, rpcType <span class="keyword">uint8</span>, args <span class="keyword">interface</span>&#123;&#125;, resp <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// ① 从连接池中获取连接，NetworkTransport维护了一个连接池</span></span><br><span class="line">	conn, err := n.getConnFromAddressProvider(id, target)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ② 发送RPC请求</span></span><br><span class="line">	<span class="keyword">if</span> err = sendRPC(conn, rpcType, args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ③ 解码Response，并且归还连接。注意：这里发送了请求之后，马上就解码Response了。想想我们的mysql客户端，(发消息,等结果），不可以一直发消息而不接收。</span></span><br><span class="line">	canReturn, err := decodeResponse(conn, resp)</span><br><span class="line">	<span class="keyword">if</span> canReturn &#123;</span><br><span class="line">		n.returnConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们对比看看InmemTransport.makeRPC方法来体会其中的不同，这边获取结果需要从respCh读取。那么，这个Response是谁塞进去respCh的呢，毕竟我们只是获取了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *InmemTransport)</span> <span class="title">makeRPC</span><span class="params">(target ServerAddress, args <span class="keyword">interface</span>&#123;&#125;, r io.Reader, timeout time.Duration)</span> <span class="params">(rpcResp RPCResponse, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义交互用的RPC对象</span></span><br><span class="line">  req := RPC&#123;</span><br><span class="line">		Command:  args,</span><br><span class="line">		Reader:   r,</span><br><span class="line">		RespChan: respCh,</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 发送消息，直接将构造出来的req灌到peer.consumerCh消费channel，本来就是内存中的对象。</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> peer.consumerCh &lt;- req:</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 等respCh结果，消费协程把RPC拿出来-处理-结果塞回到respCh。</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> rpcResp = &lt;-respCh:</span><br><span class="line">      <span class="keyword">if</span> rpcResp.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">         err = rpcResp.Error</span><br><span class="line">      &#125;</span><br><span class="line">     .... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：</p>
<p>1、上面的实现是一条一条的发，实际上为了高效，我们往往都是批处理的。</p>
<p>2、想RequestVote要给多个对象发投票消息，那么肯定不会发一个消息等一个结果，而是群发，然后处理结构。</p>
<h5 id="AppendEntriesPipeline实现"><a href="#AppendEntriesPipeline实现" class="headerlink" title="AppendEntriesPipeline实现"></a>AppendEntriesPipeline实现</h5><p>同样的我们从测试用例开始，看看批处理是怎么玩的。主要看看批处理和单条处理的区别。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化AppendEntriesPipeline对象，启动协程处理 inprogressCh -&gt; doneCh</span></span><br><span class="line">pipeline, err := trans2.AppendEntriesPipeline(<span class="string">&quot;id1&quot;</span>, trans1.LocalAddr())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发10个消息，并且将RPC加入到inprogressCh</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  out := <span class="built_in">new</span>(AppendEntriesResponse)</span><br><span class="line">  <span class="keyword">if</span> _, err := pipeline.AppendEntries(&amp;args, out); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.Fatalf(<span class="string">&quot;err: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer()会返回doneCh，从doneCh获取数据，发了10个消息，所以需要获取10次结果</span></span><br><span class="line">respCh := pipeline.Consumer()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ready := &lt;-respCh:</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是发消息的时候  非pipeline VS pipeline的区别</p>
<p><a href="https://imgtu.com/i/TCM7Us"><img src="https://s4.ax1x.com/2021/12/16/TCM7Us.md.png" alt="TCM7Us.md.png"></a></p>
<p>下面是解码消息的时候  非pipeline VS pipeline的区别，pipeline的decodeResponses方法是初始化AppendEntriesPipeline对象的时候就启动的协程。</p>
<p><a href="https://imgtu.com/i/TClAFs"><img src="https://s4.ax1x.com/2021/12/16/TClAFs.md.png" alt="TClAFs.md.png"></a></p>
<p>这里有一个❓疑问关于net.Conn的 A-&gt;B-&gt;A，这个过程在网络上是两边可以同时发送数据吗？为啥上面的非pipeline模式，send之后马上就可以decode消息了，conn这里帮我们做了什么。</p>
<p>批处理的整体实现就是，启动一个协程监控inprogress的任务。然后开发批量的发消息，比如一次发10条，然后inprogress协程被激活，开始处理。将处理的结果放到doneCh，最后用户从doneCh获取消息即可。</p>
<h5 id="RequestVote过程"><a href="#RequestVote过程" class="headerlink" title="RequestVote过程"></a>RequestVote过程</h5><p>上面我们分析了一对一pipeline发消息，下面我们来看看1:N，在集群里面给所有人发消息，并且处理结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">electSelf</span><span class="params">()</span> &lt;-<span class="title">chan</span> *<span class="title">voteResult</span></span> &#123;</span><br><span class="line">	<span class="comment">// ① 创建一个包含peers数量的respCh</span></span><br><span class="line">	respCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *voteResult, <span class="built_in">len</span>(r.configurations.latest.Servers))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ② 并发发消息，然后将结果灌回到respCh。后面从respCh获取投票结果即可进行处理。</span></span><br><span class="line">	askPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer Server)</span></span> &#123;</span><br><span class="line">		r.goFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			resp := &amp;voteResult&#123;voterID: peer.ID&#125;</span><br><span class="line">			err := r.trans.RequestVote(peer.ID, peer.Address, req, &amp;resp.RequestVoteResponse)</span><br><span class="line">			... </span><br><span class="line">			respCh &lt;- resp</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> respCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结🤔"><a href="#总结🤔" class="headerlink" title="总结🤔"></a>总结🤔</h4><p>网络是一个很复杂的模块，后续可以看看比较经典的Redis、Nginx这些优秀组件的实现。</p>
<p>ProxySQL：惊群效应思考</p>
]]></content>
      <tags>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>hashicorp:raft源码系列(1)--导读</title>
    <url>/2021/12/17/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-1-%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="Raft是干啥的？"><a href="#Raft是干啥的？" class="headerlink" title="Raft是干啥的？"></a>Raft是干啥的？</h3><p><a href="http://thesecretlivesofdata.com/raft/">动画说明</a></p>
<p>简述如下图：用户SET 5，3个不同节点都能获取SET 5的操作。所谓的最简单的分布式一致性。</p>
<p><a href="https://imgtu.com/i/oO3r0P"><img src="https://s4.ax1x.com/2021/12/13/oO3r0P.png" alt="oO3r0P.png"></a></p>
<h3 id="Raft项目包含哪些模块？"><a href="#Raft项目包含哪些模块？" class="headerlink" title="Raft项目包含哪些模块？"></a>Raft项目包含哪些模块？</h3><h4 id="项目有多少行"><a href="#项目有多少行" class="headerlink" title="项目有多少行?"></a>项目有多少行?</h4><p>分析下整个项目大概是1W多行，并不是很大，代码注释非常齐全，理解起来比较轻松。代码抽象得很好，非常值得学习。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">-&gt;</span><span class="bash"> % cloc ./</span></span><br><span class="line">      77 text files.</span><br><span class="line">      77 unique files.</span><br><span class="line">       8 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.90  T=0.09 s (814.1 files/s, 201614.7 lines/s)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Language                     files          blank        comment           code</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Go                              57           2207           2786          11864</span><br><span class="line">Markdown                         4            106              0            255</span><br><span class="line">YAML                             4             26             29            141</span><br><span class="line">XML                              4              0              0            108</span><br><span class="line">make                             1             10              2             33</span><br><span class="line">Bourne Shell                     1              3              3             10</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">SUM:                            71           2352           2820          12411</span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h4 id="从哪里开始？"><a href="#从哪里开始？" class="headerlink" title="从哪里开始？"></a>从哪里开始？</h4><p>首先，我们来看下api.go/Raft结构，表示的是一个Raft节点，最核心的数据结构。划分3大块</p>
<ol>
<li><p>NewRaft节点需要的信息：下图中标红点的，几大核心组成。下一篇我们从网络层开始详细分析。</p>
<blockquote>
<p>除了raftState，其他部分全是interface，模块抽象的很细致。</p>
</blockquote>
</li>
<li><p>Leader操作相关：整个Raft最核心的就是Leader的状态转换过程。我们后续也会对这一部分的实现做详细说明。</p>
</li>
<li><p>一些异步操作：这一块是嵌入在各个模块的实现中的。项目里面一些chan的使用也是值得学习的。</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/oO0Ein"><img src="https://s4.ax1x.com/2021/12/13/oO0Ein.png" alt="oO0Ein.png"></a></p>
<h4 id="新建Raft节点逻辑？"><a href="#新建Raft节点逻辑？" class="headerlink" title="新建Raft节点逻辑？"></a>新建Raft节点逻辑？</h4><ul>
<li><p>① 校验配置</p>
</li>
<li><p>② 获取当前任务，这里是从StableStore中获取</p>
</li>
<li><p>③ 获取最近的日志号和具体Log，从LogStore中获取</p>
</li>
<li><p>④ 创建Buffer applyCh，用来应用Log到FSM。这里Future的应用可以学习下，后面写applyLog的时候可以详细分析。</p>
</li>
<li><p>⑤ 初始化Raft结构。</p>
</li>
<li><p>⑥ Set各种变量，这里可以研究下config是怎么实现线程安全的变更。</p>
</li>
<li><p>⑦ 尝试从备份中恢复，处理peer变更日志，eg：添加节点、删除节点。这里为啥只处理Peer变更信息，都已经将Log解析出来了，为啥不直接应用呢？</p>
</li>
<li><p>⑧ 给传输层注册心跳处理器。在这里初始化，而不是在goroutine里面处理，是为了避免队头阻塞。</p>
</li>
<li><p>⑨ 启动goroutine，如下启动了3个协程。</p>
<p><a href="https://imgtu.com/i/oOhDud"><img src="https://s4.ax1x.com/2021/12/13/oOhDud.png" alt="oOhDud.png"></a></p>
</li>
</ul>
<p>代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(conf *Config, fsm FSM, logs LogStore, stable StableStore, snaps SnapshotStore, trans Transport)</span> <span class="params">(*Raft, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ① 校验配置</span></span><br><span class="line">	<span class="keyword">if</span> err := ValidateConfig(conf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ② 获取当前任务，这里是从StableStore中获取</span></span><br><span class="line">	currentTerm, err := stable.GetUint64(keyCurrentTerm)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ③ 获取最近的日志号和具体Log，从LogStore中获取；</span></span><br><span class="line">	lastIndex, err := logs.LastIndex()</span><br><span class="line">  <span class="keyword">if</span> err = logs.GetLog(lastIndex, &amp;lastLog); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to get last log at index %d: %v&quot;</span>, lastIndex, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ④ 创建Buffer applyCh，用来应用Log到FSM。这里Future的应用可以学习下。</span></span><br><span class="line">	applyCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *logFuture)</span><br><span class="line">	<span class="keyword">if</span> conf.BatchApplyCh &#123;</span><br><span class="line">		applyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> *logFuture, conf.MaxAppendEntries)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ⑤ 初始化Raft结构。</span></span><br><span class="line">	r := &amp;Raft&#123;</span><br><span class="line">    ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⑥ Set各种变量，下面这一行的实现可以研究下，为啥不直接r.conf = conf</span></span><br><span class="line">	r.conf.Store(*conf)</span><br><span class="line">	r.setState(Follower)</span><br><span class="line">	r.setCurrentTerm(currentTerm)</span><br><span class="line">	r.setLastLog(lastLog.Index, lastLog.Term)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ⑦ 尝试从备份中恢复，处理peer变更日志，eg：添加节点、删除节点. </span></span><br><span class="line">	<span class="keyword">if</span> err := r.restoreSnapshot(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	snapshotIndex, _ := r.getLastSnapshot()</span><br><span class="line">	<span class="keyword">for</span> index := snapshotIndex + <span class="number">1</span>; index &lt;= lastLog.Index; index++ &#123;</span><br><span class="line">		<span class="keyword">var</span> entry Log</span><br><span class="line">		<span class="keyword">if</span> err := r.logs.GetLog(index, &amp;entry); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := r.processConfigurationLogEntry(&amp;entry); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// ⑧ 给传输层注册心跳处理器</span></span><br><span class="line">	trans.SetHeartbeatHandler(r.processHeartbeat)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ⑨ 启动goroutine</span></span><br><span class="line">	r.goFunc(r.run)</span><br><span class="line">	r.goFunc(r.runFSM)</span><br><span class="line">	r.goFunc(r.runSnapshots)</span><br><span class="line">	<span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此，我们就将Raft节点启动起来了</p>
<h4 id="技术点1：atomic-Value"><a href="#技术点1：atomic-Value" class="headerlink" title="技术点1：atomic.Value"></a>技术点1：atomic.Value</h4><p><img src="https://blog.betacat.io/image/golang-atomic-value/atomic-value-store.drawio.png" alt="atomic.Value Store 流程"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// conf这个变量会涉及到多个goroutine的并发修改&amp;读取。</span></span><br><span class="line"><span class="comment">// 为了保证读写的原子性，通常我们会加锁。但是加锁又有点过重了，为了更加高效的实现，使用了atomic。</span></span><br><span class="line">conf atomic.Value</span><br><span class="line">r.conf.Store(*conf)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 8个写routine + 1个读routine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAtomic</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> gloMy = my&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				tmp := rand.Uint64() % <span class="number">100</span></span><br><span class="line">				gloMy.v1 = tmp</span><br><span class="line">        <span class="comment">// 在这两次操作之间就会产生中间状态，这个状态就很奇怪没有意义</span></span><br><span class="line">				gloMy.v2 = fmt.Sprintf(<span class="string">&quot;s%d&quot;</span>, tmp)</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			t.Log(gloMy.v1, gloMy.v2)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=== RUN   TestAtomic</span><br><span class="line">    tmp_test.<span class="keyword">go</span>:<span class="number">33</span>: <span class="number">75</span> s64 <span class="comment">// 不合符预期，脏读了</span></span><br><span class="line">    tmp_test.<span class="keyword">go</span>:<span class="number">33</span>: <span class="number">63</span> s63</span><br><span class="line">    tmp_test.<span class="keyword">go</span>:<span class="number">33</span>: <span class="number">48</span> s48</span><br><span class="line">    tmp_test.<span class="keyword">go</span>:<span class="number">33</span>: <span class="number">5</span> s5</span><br><span class="line">    tmp_test.<span class="keyword">go</span>:<span class="number">33</span>: <span class="number">1</span> s1</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.betacat.io/post/golang-atomic-value-exploration/">推荐一篇文章</a> ：文中将atomic的来龙去脉都解释了一遍。</p>
<h4 id="技术点2：队头阻塞"><a href="#技术点2：队头阻塞" class="headerlink" title="技术点2：队头阻塞"></a>技术点2：队头阻塞</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这行的位置，在goroutine启动之前注册HeartbeatHandler处理器</span></span><br><span class="line">trans.SetHeartbeatHandler(r.processHeartbeat)</span><br></pre></td></tr></table></figure>



<h4 id="小小疑问❓"><a href="#小小疑问❓" class="headerlink" title="小小疑问❓"></a>小小疑问❓</h4><p>Q: 为啥要叫FSM，我的理解FSM不就是类似于MySQL这种可以应用Log的地方吗？总感觉用状态机命名怪怪的，容易误会。</p>
<p>Q: Config 和 Configuration的区别? Config里面都是单个Raft节点的配置，比如超时之类的；Configuration是Raft Cluster相关的信息，比如有几个节点之类的。</p>
<p>​           </p>
]]></content>
      <tags>
        <tag>raft</tag>
      </tags>
  </entry>
</search>
