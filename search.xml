<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>怎么将youtube视频搬运到B站</title>
    <url>/2022/02/10/%E6%80%8E%E4%B9%88%E5%B0%86youtube%E8%A7%86%E9%A2%91%E6%90%AC%E8%BF%90B%E7%AB%99/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>需求：将YouTube的视频搬运到B站里面来。文章主要讲了以下几点</p>
<ul>
<li>怎样下载YouTube视频</li>
<li>怎样上传B站</li>
<li>怎样添加字幕</li>
<li>Mac怎么做视频合集</li>
</ul>
<h3 id="前提说明"><a href="#前提说明" class="headerlink" title="前提说明"></a>前提说明</h3><ol>
<li>B站账号 &amp; YouTube账号</li>
<li>能访问YouTube的网络环境</li>
</ol>
<blockquote>
<p>笔者使用的Mac电脑，下面的所有操作均基于MacOS</p>
</blockquote>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><h4 id="1-安装youtube-dl"><a href="#1-安装youtube-dl" class="headerlink" title="1. 安装youtube-dl"></a>1. 安装<code>youtube-dl</code></h4><p>项目github地址：<a href="https://github.com/ytdl-org/youtube-dl">https://github.com/ytdl-org/youtube-dl</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install youtube-dl</span><br></pre></td></tr></table></figure>

<h4 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2. 安装依赖"></a>2. 安装依赖</h4><p>安装youtube-dl运行需要的依赖</p>
<ul>
<li>ffmpeg用来对字幕格式进行转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure>

<h4 id="3-下载视频"><a href="#3-下载视频" class="headerlink" title="3. 下载视频"></a>3. 下载视频</h4><p>常用操作</p>
<ul>
<li><p>下载单个视频</p>
</li>
<li><p>下载视频列表</p>
</li>
<li><p>下载自动生成的字幕，默认是英文</p>
</li>
</ul>
<blockquote>
<p>  默认下载的是vvt，这个格式B站上不支持。</p>
<p>  字幕格式转换请使用字幕格式转换请使用 –write-auto-sub –convert-subs=srt</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载单个视频</span></span><br><span class="line">youtube-dl --write-auto-sub --convert-subs=srt https://www.youtube.com/watch?v=clFR9NfObvc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载视频列表</span></span><br><span class="line">youtube-dl --yes-playlist --write-auto-sub --convert-subs=srt -o &#x27;%(playlist)s/%(playlist_index)s-%(title)s.%(ext)s&#x27; https://www.youtube.com/playlist?list=PLWwSgbaBp9XqeuIuTWqpNtvf_EL0I4TJ2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他常用说明</span> </span><br><span class="line">--skip-download 单独下载字幕，不下载文件</span><br><span class="line">--write-sub  下载自动生成的字幕</span><br><span class="line">--convert-subs=srt 转换字幕格式</span><br><span class="line">--embed-subs  视频中嵌入字幕</span><br></pre></td></tr></table></figure>

<!--最简单的是使用--embed-subs，但是笔者尝试了一个视频并未成功，求指教-->

<p>可选：如果使用的是Mac电脑，可直接<a href="https://www.macwk.com/soft/4k-video-downloader">点击这里</a>下载对应软件来下载(灰常简单)。</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220210143706701.png" alt="image-20220210143706701" style="zoom:50%;float:left" />

<blockquote>
<ol>
<li>如果同时下载并发开得太大，容易发生卡死在最后不同。本人：2个并发，网速2MB/s是OK的</li>
<li>软件不支持断点下载，退出后全部重来。求好的方法~</li>
</ol>
</blockquote>
<h4 id="4-上传视频"><a href="#4-上传视频" class="headerlink" title="4. 上传视频"></a>4. 上传视频</h4><p>采坑&amp;总结的tips</p>
<ul>
<li><p>B站上传的视频需要审核，大部分说是20min</p>
</li>
<li><p>会有重复视频检查，今早上传</p>
</li>
<li><p>Playlist最好一次性将所有的视频上传，后面有更新在编辑</p>
</li>
</ul>
<h4 id="5-添加字幕-可选"><a href="#5-添加字幕-可选" class="headerlink" title="5. 添加字幕(可选)"></a>5. 添加字幕(可选)</h4><p>字幕和视频并非同步上传</p>
<ol>
<li>找到对应的视频页</li>
<li>点击字幕按钮，并添加上面下载的字幕文件，如下图。</li>
</ol>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220210143922087.png" alt="image-20220210143922087" style="zoom:50%;float:left" />

<h4 id="6-发布blog-可选"><a href="#6-发布blog-可选" class="headerlink" title="6. 发布blog(可选)"></a>6. 发布blog(可选)</h4><p>笔者基本是学习一个视频总结一个blog，所以上传视频之后会上传对应的文章. 视频优先，视频好些都是一次性上传的。</p>
<ul>
<li>投稿-&gt;专栏管理</li>
<li>对.md文稿支持不太行</li>
</ul>
<h4 id="7-怎么做视频合集"><a href="#7-怎么做视频合集" class="headerlink" title="7. 怎么做视频合集"></a>7. 怎么做视频合集</h4><p>Mac上没有上传工具，没法做视频合集</p>
<ul>
<li>在Mac上安装虚拟机，虚拟机上安装window系统，然后安装上传工具，就可以弄合集了。虚拟机是真的很重，不想这样</li>
<li>github有<a href="https://github.com/WLiK/Move_Video_to_Bilibili/blob/main/readme.md">脚本</a>，需要有一定的程序基础</li>
<li>求各位指教简单好用的方案</li>
</ul>
]]></content>
      <tags>
        <tag>youtube</tag>
        <tag>视频搬运</tag>
        <tag>添加字幕</tag>
        <tag>视频合集</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么实现一个分布式kv系统(1)-本地db</title>
    <url>/2022/01/30/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8Fkv%E7%B3%BB%E7%BB%9F-1-%E6%9C%AC%E5%9C%B0db/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>本节要实现的有2点</p>
<ul>
<li>环境配置：远程服务器 + VS Code设置</li>
<li>实现类似redis的set和get功能<ul>
<li>基于bolt.DB实现db模块</li>
<li>实现简单的http web模块</li>
</ul>
</li>
</ul>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="1-远程服务器-可选择"><a href="#1-远程服务器-可选择" class="headerlink" title="1. 远程服务器[可选择]"></a>1. 远程服务器[可选择]</h4><p>远程服务器比较稳定，当然也是多折腾体验。</p>
<p>腾讯云服务器购买详情&amp;一些奇奇怪怪的软件设置，请参考: <a href="https://blog.csdn.net/luzhangting/article/details/122435641">详细的配置信息</a></p>
<h4 id="2-配置VSCode"><a href="#2-配置VSCode" class="headerlink" title="2. 配置VSCode"></a>2. 配置VSCode</h4><p>安装 Remote SSH插件</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220130144339299.png" alt="image-20220130144339299" style="zoom:50%;float:left" />

<p>连接服务器</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220130144737817.png" alt="image-20220130144737817" style="zoom:50%;float:left" />

<p>切换第一个tab，打开资源管理器，添加目录</p>
<h4 id="3-设置go-mod"><a href="#3-设置go-mod" class="headerlink" title="3. 设置go mod"></a>3. 设置go mod</h4><p>查看go版本和配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-14-centos ~]# go version</span><br><span class="line">go version go1.17 linux/amd64</span><br><span class="line">[root@VM-24-14-centos ~]# echo $GOPATH</span><br><span class="line">/data/go</span><br><span class="line">[root@VM-24-14-centos ~]# echo $GOROOT</span><br><span class="line">/usr/local/go</span><br></pre></td></tr></table></figure>

<p>vscode安装tools</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220130145506314.png" alt="image-20220130145506314" style="zoom:50%;float:left" />

<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220130145616468.png" alt="image-20220130145616468" style="zoom:50%;float:left" />

<p>设置vscode go的选项</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;go.installDependenciesWhenBuilding&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;go.useCodeSnippetsOnFunctionSuggestWithoutType&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;go.autocompleteUnimportedPackages&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;go.gotoSymbol.includeImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;go.useCodeSnippetsOnFunctionSuggest&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;go.inferGopath&quot;</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220130150202540.png" alt="image-20220130150202540" style="zoom:50%;float:left" />

<h3 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h3><h4 id="1-导入boltdb"><a href="#1-导入boltdb" class="headerlink" title="1. 导入boltdb"></a>1. 导入boltdb</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-14-centos go]# mkdir kv-demo</span><br><span class="line">[root@VM-24-14-centos go]# cd kv-demo</span><br><span class="line">[root@VM-24-14-centos kv-demo]# go mod init example.com/kv-demo</span><br><span class="line">[root@VM-24-14-centos kv-demo]# go mod tidy</span><br><span class="line">[root@VM-24-14-centos kv-demo]# go mod vendor</span><br><span class="line">[root@VM-24-14-centos kv-demo]# go run main.go</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220130151055573.png" alt="image-20220130151055573" style="zoom:50%;float:left" />

<h4 id="2-设置flag"><a href="#2-设置flag" class="headerlink" title="2. 设置flag"></a>2. 设置flag</h4><p>目前就一个参数db-location,后续可以添加</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  dbLocation = flag.String(<span class="string">&quot;db-location&quot;</span>, <span class="string">&quot;my.db&quot;</span>, <span class="string">&quot;The path to the database location&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  db, err := bolt.Open(*dbLocation, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-创建HTTP-API"><a href="#3-创建HTTP-API" class="headerlink" title="3. 创建HTTP API"></a>3. 创建HTTP API</h4><p>先简单的mock http api</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/get&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Get Called&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/set&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprintf(w, <span class="string">&quot;Set called&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8090&quot;</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-14-centos kv-demo]# curl http://127.0.0.1:8090/set</span><br><span class="line">Set called</span><br><span class="line">[root@VM-24-14-centos kv-demo]# curl http://127.0.0.1:8090/get</span><br><span class="line">Get Called</span><br></pre></td></tr></table></figure>

<h4 id="4-DB模块"><a href="#4-DB模块" class="headerlink" title="4. DB模块"></a>4. DB模块</h4><p>目前位置db的功能都在main里面，我们分离出单独的db模块</p>
<ul>
<li>创建DB</li>
<li>设置key</li>
<li>获取key</li>
<li>创建默认Bucket</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">(dbLocation <span class="keyword">string</span>)</span> <span class="params">(db *Database, closeFunc <span class="keyword">func</span>()</span> <span class="title">error</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">  boltDb, err := bolt.Open(dbLocation, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  db = &amp;Database&#123;db: boltDb&#125;</span><br><span class="line">  closeFunc = boltDb.Close</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := db.createDefaultBucket(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;create default bucket failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> db, closeFunc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span> <span class="title">SetKey</span><span class="params">(key <span class="keyword">string</span>, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> db.db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    b := tx.Bucket(defaultBucket)</span><br><span class="line">    <span class="keyword">return</span> b.Put([]<span class="keyword">byte</span>(key), value)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span> <span class="title">GetKey</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> rc []<span class="keyword">byte</span></span><br><span class="line">  err := db.db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    b := tx.Bucket(defaultBucket)</span><br><span class="line">    rc = b.Get([]<span class="keyword">byte</span>(key))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> rc, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span> <span class="title">createDefaultBucket</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> db.db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := tx.CreateBucketIfNotExists([]<span class="keyword">byte</span>(defaultBucket))</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-更新API"><a href="#5-更新API" class="headerlink" title="5. 更新API"></a>5. 更新API</h4><p>更新set &amp; get http api来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/get&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseForm()</span><br><span class="line">  key := r.Form.Get(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">  value, err := db.GetKey(key)</span><br><span class="line">  fmt.Fprintf(w, <span class="string">&quot;%q:%q; %v Get Called\n&quot;</span>, key, value, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/set&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseForm()</span><br><span class="line">  key := r.Form.Get(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">  value := r.Form.Get(<span class="string">&quot;value&quot;</span>)</span><br><span class="line">  err := db.SetKey(key, []<span class="keyword">byte</span>(value))</span><br><span class="line">  fmt.Fprintf(w, <span class="string">&quot;err: %v; Set called\n&quot;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h4><ul>
<li>Set a:b</li>
<li>Get a</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-24-14-centos src]# curl &#x27;http://127.0.0.1:8090/set?value=b&amp;key=a&#x27;</span><br><span class="line">&quot;a&quot;:&quot;b&quot;; &lt;nil&gt;; Set called</span><br><span class="line">[root@VM-24-14-centos src]# curl http://127.0.0.1:8090/get?key=a</span><br><span class="line">&quot;a&quot;:&quot;b&quot;; &lt;nil&gt; Get Called</span><br></pre></td></tr></table></figure>

<h4 id="7-web分离"><a href="#7-web分离" class="headerlink" title="7. web分离"></a>7. web分离</h4><p>类似db分离，web也是单独的模块</p>
<ul>
<li>创建</li>
<li>处理get</li>
<li>处理set</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">  db *db.Database</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(db *db.Database)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Server&#123;db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">GetHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseForm()</span><br><span class="line">  key := r.Form.Get(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">  value, err := s.db.GetKey(key)</span><br><span class="line">  fmt.Fprintf(w, <span class="string">&quot;%q:%q; %v Get Called\n&quot;</span>, key, value, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">SetHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseForm()</span><br><span class="line">  key := r.Form.Get(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">  value := r.Form.Get(<span class="string">&quot;value&quot;</span>)</span><br><span class="line">  err := s.db.SetKey(key, []<span class="keyword">byte</span>(value))</span><br><span class="line">  fmt.Fprintf(w, <span class="string">&quot;%q:%q; %v; Set called\n&quot;</span>, key, value, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-更新main"><a href="#8-更新main" class="headerlink" title="8. 更新main"></a>8. 更新main</h4><p>web模块在main中调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">svr := web.NewServer(db)</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/get&quot;</span>, svr.GetHandler)</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/set&quot;</span>, svr.SetHandler)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(*httpAddress, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>本节完整代码：<a href="https://github.com/YuriyNasretdinov/distribkv/tree/part1">https://github.com/YuriyNasretdinov/distribkv/tree/part1</a></p>
<p>youtube视频：<a href="https://www.youtube.com/watch?v=oPwGrCoOUdo&amp;list=PLWwSgbaBp9XrMkjEhmTIC37WX2JfwZp7I&amp;index=2">https://www.youtube.com/watch?v=oPwGrCoOUdo&amp;list=PLWwSgbaBp9XrMkjEhmTIC37WX2JfwZp7I&amp;index=2</a></p>
<p>B站视频：<a href="https://www.bilibili.com/video/BV1nR4y177YM?p=1">https://www.bilibili.com/video/BV1nR4y177YM?p=1</a></p>
]]></content>
      <tags>
        <tag>kv</tag>
        <tag>local database</tag>
      </tags>
  </entry>
  <entry>
    <title>用Go实现一步步实现的分布式Key-Value数据库(0)-实现目标</title>
    <url>/2022/01/30/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8Fkv%E7%B3%BB%E7%BB%9F-0-%E5%AE%9E%E7%8E%B0%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>本节为《用Go实现一步步实现的分布式Key-Value数据库》系列的第一篇，讲了我们这个系列要实现啥目标。</p>
<h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220228182912030.png" alt="image-20220228182912030" style="zoom:100%; float:left" />

<p>SRV1-4：写节点</p>
<p>RPL1-4：读节点 </p>
<p>红色箭头: 写流量</p>
<p>绿色箭头：读流量</p>
<p>SVR1-&gt;RPL1: 数据同步</p>
<p>Magic组件主要实现的几点功能：</p>
<ul>
<li>写主库，读从库</li>
<li>数据路由，路由规则：Server(“key”) = Hash(“key”)%NUM</li>
<li>数据同步，写节点-&gt;读节点</li>
</ul>
]]></content>
      <tags>
        <tag>摘要</tag>
      </tags>
  </entry>
  <entry>
    <title>go-包管理</title>
    <url>/2022/01/21/go-%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>每次打开IDE，都变红。如果超过3次，我想着是不是应该将事实弄明白呢。</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220121111115117.png" alt="image-20220121111115117" style="zoom:100%;float:left" />

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h5 id="1、为啥会报错？"><a href="#1、为啥会报错？" class="headerlink" title="1、为啥会报错？"></a>1、为啥会报错？</h5><blockquote>
<p>肯定是找不到对应的pkg</p>
</blockquote>
<h5 id="2、那IDE到底是去哪里找了呢？"><a href="#2、那IDE到底是去哪里找了呢？" class="headerlink" title="2、那IDE到底是去哪里找了呢？"></a>2、那IDE到底是去哪里找了呢？</h5><blockquote>
<p>理论上是gopath路径下面，👇🏻GOPATH=”/root/gopath” 这里，IDE里面可以设置的项目更多</p>
</blockquote>
<p>go env的输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GO111MODULE=&quot;on&quot; </span><br><span class="line">GOPATH=&quot;/root/gopath&quot;</span><br><span class="line">GOPROXY=&quot;https://goproxy.cn,direct&quot;  # 设置代理，go get的时候快点</span><br><span class="line">GOROOT=&quot;/usr/local/go&quot;  # go二进制包的安装地址</span><br><span class="line">GOVERSION=&quot;go1.17&quot;  # go版本</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220121181545764.png" alt="image-20220121181545764" style="zoom:100%;float:left" />

<h5 id="3、实际上GOPATH下面是有需要的pkg的"><a href="#3、实际上GOPATH下面是有需要的pkg的" class="headerlink" title="3、实际上GOPATH下面是有需要的pkg的"></a>3、实际上GOPATH下面是有需要的pkg的</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要的包</span>	</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> % ll /Users/linmi/go/pkg/mod/github.com/prometheus</span></span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x   23 linmi  staff   736B  1 21 12:01 client_golang@v1.12.0</span><br><span class="line">dr-xr-xr-x   13 linmi  staff   416B  1 21 12:01 client_model@v0.2.0</span><br><span class="line">dr-xr-xr-x   24 linmi  staff   768B  1 21 12:01 common@v0.32.1</span><br><span class="line">dr-xr-xr-x  122 linmi  staff   3.8K  1 21 12:01 procfs@v0.7.3</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> IDE报错的路径</span></span><br><span class="line">/Users/linmi/go/pkg/mod/src/github.com/prometheus/client_golang/prometheus/promhttp (from $GOPATH)</span><br></pre></td></tr></table></figure>

<p>📢：IDE报错的路径里面多了一层<code>src</code>目录，这就有点出乎意料了。</p>
<h5 id="4、最佳实践"><a href="#4、最佳实践" class="headerlink" title="4、最佳实践"></a>4、最佳实践</h5><p>gopath和go mod是互斥的，现在的话肯定是go mod了。最简单&amp;有效的方法，类似python那样，各个项目自己管理自己的包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go mod vendor # 创建vendor依赖</span><br><span class="line">go mod tidy </span><br></pre></td></tr></table></figure>

<p>IDE打开go modules的选项，问题自然就解决了</p>
<h5 id="5、Mac上go多版本怎么管理"><a href="#5、Mac上go多版本怎么管理" class="headerlink" title="5、Mac上go多版本怎么管理"></a>5、Mac上go多版本怎么管理</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先确认是不是brew管理</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> % <span class="built_in">which</span> go</span></span><br><span class="line">/usr/local/bin/go</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> % ll -h /usr/<span class="built_in">local</span>/bin/go</span></span><br><span class="line">lrwxr-xr-x  1 linmi  admin    26B 10 12 23:34 /usr/local/bin/go -&gt; ../Cellar/go/1.17.2/bin/go # Cellar这里就能说明是的</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接着看看有哪些版本，我的本机有3个版本</span></span><br><span class="line">ll /usr/local/opt | grep go  # opt=options查看可选择的版本</span><br><span class="line">lrwxr-xr-x  1 linmi  admin    19B 10 12 23:34 go -&gt; ../Cellar/go/1.17.2</span><br><span class="line">lrwxr-xr-x  1 linmi  admin    25B 10 13 10:54 go@1.15 -&gt; ../Cellar/go@1.15/1.15.15</span><br><span class="line">lrwxr-xr-x  1 linmi  admin    24B  9 23 11:27 go@1.16 -&gt; ../Cellar/go@1.16/1.16.8</span><br><span class="line">lrwxr-xr-x  1 linmi  admin    19B 10 12 23:34 go@1.17 -&gt; ../Cellar/go/1.17.2</span><br><span class="line">lrwxr-xr-x  1 linmi  admin    19B 10 12 23:34 golang -&gt; ../Cellar/go/1.17.2</span><br><span class="line">lrwxr-xr-x  1 linmi  admin    19B 10 12 23:34 google-go -&gt; ../Cellar/go/1.17.2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 那要怎么使用brew快捷的进行设置呢</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> % brew link go</span></span><br><span class="line">Warning: Already linked: /usr/local/Cellar/go/1.17.2</span><br><span class="line">To relink, run:</span><br><span class="line">  brew unlink go &amp;&amp; brew link go   # 重新回到最近的版本</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash">% brew link --overwrite go@1.16  <span class="comment"># 看这个就知道是重写了</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>go</tag>
        <tag>包管理</tag>
      </tags>
  </entry>
  <entry>
    <title>tikv-4-DEADLINE_EXCEEDED</title>
    <url>/2022/01/20/tikv-4-DEADLINE-EXCEEDED/</url>
    <content><![CDATA[<h3 id="报错详情"><a href="#报错详情" class="headerlink" title="报错详情"></a>报错详情</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2022/01/20 12:38:23.922 +08:00] [WARN] [prewrite.rs:469] [&quot;commit_ts is too large, fallback to normal 2PC&quot;] [lock=&quot;Lock &#123; lock_type: Delete, primary_key: 7480000000000000415F6980000000000000010380000000002AB89803800000000026466A, start_ts: TimeStamp(430611757768638581), ttl: 4003, short_value: , for_update_ts: TimeStamp(0), txn_size: 1, min_commit_ts: TimeStamp(430611757768638582), use_async_commit: true, secondaries: [], rollback_ts: [] &#125;&quot;] [max_commit_ts=430611758555857013] [min_commit_ts=430611760114565123] [start_ts=430611757768638581] [key=7480000000000000FF415F728000000000FF26466A0000000000FA]</span><br><span class="line">[2022/01/20 12:38:29.199 +08:00] [INFO] [compaction_filter.rs:501] [&quot;Compaction filter reports&quot;] [filtered=382901] [total=2812852]</span><br><span class="line">[2022/01/20 12:38:40.004 +08:00] [ERROR] [util.rs:419] [&quot;request failed, retry&quot;] [err_code=KV:PD:gRPC] [err=&quot;Grpc(RpcFailure(RpcStatus &#123; code: 4-DEADLINE_EXCEEDED, message: \&quot;Deadline Exceeded\&quot;, details: [] &#125;))&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3>]]></content>
      <tags>
        <tag>tikv</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo文章设置草稿-暂不发布-文章分类</title>
    <url>/2022/01/12/hexo%E6%96%87%E7%AB%A0%E8%AE%BE%E7%BD%AE%E8%8D%89%E7%A8%BF-%E6%9A%82%E4%B8%8D%E5%8F%91%E5%B8%83-%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>1、每次执行hexo d -g都会将所有的所有文章push上去，有的文章其实一个是没有写完，一个是敏感信息还需要处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new draft &lt;title&gt;  # source/_drafts</span><br><span class="line">hexo P &lt;filename&gt;       # source/_drafts  -&gt;  source/_post</span><br></pre></td></tr></table></figure>

<p>2、能不能分类，当前所有的文章都在source/_posts下面(如下图)，后面越来越多，真的不好管理，也不好找</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220112102324526.png" alt="image-20220112102324526" style="zoom:50%;float:left" />

<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4>]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>草稿</tag>
        <tag>文章分类</tag>
      </tags>
  </entry>
  <entry>
    <title>买一个3年腾讯云服务-日常开发使用</title>
    <url>/2022/01/11/%E4%B9%B0%E4%B8%80%E4%B8%AA3%E5%B9%B4%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1-%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="背景2022-01-11-–-腾讯云服务器开发"><a href="#背景2022-01-11-–-腾讯云服务器开发" class="headerlink" title="背景2022-01-11 – 腾讯云服务器开发"></a>背景2022-01-11 – 腾讯云服务器开发</h3><p>今天在看大佬写代码的过程中，大佬说我不想在本地开发，环境重启麻烦，我想万分赞同。每次换电脑都是烦人。</p>
<p>然后我就打开了阿里云，一看好贵，接着打开了腾讯云，嗯，好像便宜点。我承认我就是被下面的广告吸引的。然后我就点了立即购买的按钮😂</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220111143908730.png" alt="image-20220111143908730" style="zoom:50%;float:left" />

<p>接着我想1核2G实在是气质不符，头脑一热2核4G，一看1年虽然也很长， 不过3年好像更不用操心，主要是怕被催账。</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220111144433048.png" alt="image-20220111144433048" style="zoom:50%;float:left" />

<p>好，接着就是打开微信-绑定+付钱了,订单就好了</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220111144703537.png" alt="image-20220111144703537" style="zoom:50%;float:left" />

<h4 id="ssh登录设置"><a href="#ssh登录设置" class="headerlink" title="ssh登录设置"></a>ssh登录设置</h4><p>说实话，不论是阿里云还是腾讯云的web都异常的复杂，各种点点点都是产品+产品，账单+账单。就想问刚买的服务器去哪了。</p>
<p>不浪费时间：<a href="https://console.cloud.tencent.com/lighthouse/instance/index">https://console.cloud.tencent.com/lighthouse/instance/index</a>  chrome保存🔖吧，找起来费劲。</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220111145804003.png" alt="image-20220111145804003" style="zoom:50%;float:left" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 编辑sshd_config,如下</span></span></span><br><span class="line">sudo vi /etc/ssh/sshd_config</span><br><span class="line">[lighthouse@VM-24-14-centos ~]$ # vim /etc/ssh/sshd_config </span><br><span class="line">[lighthouse@VM-24-14-centos ~]$ # PermitRootLogin yes 去掉注释</span><br><span class="line">[lighthouse@VM-24-14-centos ~]$ # pubkeyAuthentication yes 去掉注释</span><br><span class="line">[lighthouse@VM-24-14-centos ~]$ # PasswordAuthentication yes 去掉注释</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启sshd服务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="本机配置ssh并登录"><a href="#本机配置ssh并登录" class="headerlink" title="本机配置ssh并登录"></a>本机配置ssh并登录</h4><p>找到公网ip</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220111150006715.png" alt="image-20220111150006715" style="zoom:50%;float:left" />

<p>将本机的公钥通过ssh-copy-id拷贝到remote host</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id root@ip</span><br><span class="line">ssh root@ip  # 直接登录</span><br></pre></td></tr></table></figure>

<h4 id="通过vscode登录并且code"><a href="#通过vscode登录并且code" class="headerlink" title="通过vscode登录并且code"></a>通过vscode登录并且code</h4><h5 id="先安装remote-ssh插件"><a href="#先安装remote-ssh插件" class="headerlink" title="先安装remote ssh插件"></a>先安装remote ssh插件</h5><img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220111150257939.png" alt="image-20220111150257939" style="zoom:50%;float:left" />

<h5 id="输入ssh-root-ip并选择ssh-config，原谅色出现搞完，接着就是愉快的coding"><a href="#输入ssh-root-ip并选择ssh-config，原谅色出现搞完，接着就是愉快的coding" class="headerlink" title="输入ssh root@ip并选择ssh config，原谅色出现搞完，接着就是愉快的coding"></a>输入ssh root@ip并选择ssh config，原谅色出现搞完，接着就是愉快的coding</h5><img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220111150401476.png" alt="image-20220111150401476" style="zoom:50%;float:left" />

<h5 id="打开远端的文件"><a href="#打开远端的文件" class="headerlink" title="打开远端的文件"></a>打开远端的文件</h5><img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220111151140566.png" alt="image-20220111151140566" style="zoom:50%;float:left" />

<h5 id="删除下remote-host，比如ip写错了之类，编辑-ssh-config文件才行"><a href="#删除下remote-host，比如ip写错了之类，编辑-ssh-config文件才行" class="headerlink" title="删除下remote host，比如ip写错了之类，编辑~/.ssh/config文件才行"></a>删除下remote host，比如ip写错了之类，编辑~/.ssh/config文件才行</h5><img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220111151753449.png" alt="image-20220111151753449" style="zoom:50%;float:left" />

<h5 id="自己安装需要的插件，注意本地和远程是不一样的"><a href="#自己安装需要的插件，注意本地和远程是不一样的" class="headerlink" title="自己安装需要的插件，注意本地和远程是不一样的"></a>自己安装需要的插件，注意本地和远程是不一样的</h5><img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220111152351292.png" alt="image-20220111152351292" style="zoom:50%;float:left" />

<h5 id="在centos7上安装go，设置go-env"><a href="#在centos7上安装go，设置go-env" class="headerlink" title="在centos7上安装go，设置go env"></a>在centos7上安装go，设置go env</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">yum update -y</span><br><span class="line">yum install -y go # 安装的是1.15</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="为啥这个导入会报错呢？-嗯，大概率就是环境的问题，用个go-mod-init解决就行"><a href="#为啥这个导入会报错呢？-嗯，大概率就是环境的问题，用个go-mod-init解决就行" class="headerlink" title="为啥这个导入会报错呢？ 嗯，大概率就是环境的问题，用个go mod init解决就行"></a>为啥这个导入会报错呢？ 嗯，大概率就是环境的问题，用个go mod init解决就行</h5><img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220111161358986.png" alt="image-20220111161358986" style="zoom:50%;float:left" />

<p>2021-01-11今天先到这，等会面有新的想法了在更新</p>
<p>2021-01-14号，接着上面，被攻击了</p>
<h3 id="背景2021-01-14-腾讯云服务器被攻击"><a href="#背景2021-01-14-腾讯云服务器被攻击" class="headerlink" title="背景2021-01-14-腾讯云服务器被攻击"></a>背景2021-01-14-腾讯云服务器被攻击</h3><p>我的腾讯云的轻量服务器，突然给我发消息说我有违规行为，我就开了22端口做了一个远程登录😂</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220114115516893.png" alt="image-20220114115516893" style="zoom:50%;float:left" />

<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>1、我先等了一天，通知的24h接触封禁</p>
<p>2、结果还是不能登录</p>
<p>3、客服说得用VNC登录，<a href="https://cloud.tencent.com/document/product/1207/46824">https://cloud.tencent.com/document/product/1207/46824</a> ， 就是下面的这个按钮</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220114115847427.png" alt="image-20220114115847427" style="zoom:50%;float:left" />

<p>4、我发现得要个密码不是，可是没有初始密码，记住第一次必须是重置密码，在页面上ctrl+f搜索密码,就是下面的&lt;重置密码&gt;按钮。实际上操作就是之前我们做的sudo passwd root  – 注意这里前往不要弄的太简单了，真的很容易被破解。</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220114120029547.png" alt="image-20220114120029547" style="zoom:50%;float:left" />

<p>5、好了一次次重启之后你就可以在&lt;页面上&gt;正常登录了，接着肯定是本机登录，发现就出现了下面的东西😂</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">-&gt;</span><span class="bash"> % ssh root@ip</span></span><br><span class="line">root@ip: Permission denied (publickey,gssapi-keyex,gssapi-with-mic).</span><br></pre></td></tr></table></figure>

<p>6、为啥不行了呢， 看文档说是要么使用密码，要么使用秘钥，实际上是都可以用，不过就是授权的方式不同</p>
<ul>
<li>管理密钥  <a href="https://cloud.tencent.com/document/product/1207/44573">https://cloud.tencent.com/document/product/1207/44573</a></li>
</ul>
<p>因为之前我们登录过，在~/.ssh/known_hosts这里已经有ip记录了，把对应ip的记录去掉再试。</p>
<p>7、调整好了之后我们接着ssh root@ip, 这些更好了，直接给我闪退了。同时，我还发现了一个新问题，我不能su root了</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220114141342311.png" alt="image-20220114141342311" style="zoom:50%;float:left" />

<p>8、突然，我的服务器咋了，被攻击了~ 盲猜应该是将我的ssh服务给篡改了。导致了我ssh连接了就闪退，还有我不能切换root账号。</p>
<p>9、好在我没啥东西，其实我觉得重新安装sshd即可，但是为了保险起见，我还是重新安装OS吧。</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220114142036461.png" alt="image-20220114142036461" style="zoom:50%;float:left" />

<p>好家伙，这个操作贼快，这个所谓的轻量服务器容器没跑了</p>
<p>10、为啥ssh-copy-id不需要密码？对比手动和ssh-copy-id，大概是ssh-copy-id有固定程序吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 手动</span></span><br><span class="line">ssh root@ip # 输入root密码</span><br><span class="line">vim ~/.ssh/authorized_keys  # 添加公钥</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh-copy-id</span></span><br><span class="line">ssh-copy-id root@ip # 不需要输入密码 -- 为啥？</span><br></pre></td></tr></table></figure>

<p>11、公钥和私钥是怎么一起起作用的?</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先说问题的来源</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本机 -&gt; remote</span></span><br><span class="line">ssh-copy-id 将本地的公钥copy到 ~/.ssh/authorized_keys    ---&gt;  本地可以登录远端</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 腾讯云 授权过程  秘钥管理</span></span><br><span class="line">生成秘钥一对，本地保存私钥</span><br><span class="line">下发公钥到实例</span><br><span class="line">ssh -i 私钥 root@ip </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 实际上也是一样的，本地连接的时候使用私钥去匹配remote ~/.ssh/authorized_keys 里面的公钥。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 经历一些问题可以更快的去理解很多东西的原理</span></span><br></pre></td></tr></table></figure>

<h3 id="背景2021-01-26-RAKsmart云服务器被攻击"><a href="#背景2021-01-26-RAKsmart云服务器被攻击" class="headerlink" title="背景2021-01-26-RAKsmart云服务器被攻击"></a>背景2021-01-26-RAKsmart云服务器被攻击</h3><p>写着写着我发现越写越长，真行，但是我也懒得再开一篇，毕竟都是一个系列的，折腾完了国内的服务器，就开始折腾国外的了。</p>
<p>1、为啥选择RAKsmart，货比三家性价比，算了，就是最便宜</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220126144535536.png" alt="image-20220126144535536" style="zoom:80%;float:left" />

<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220126144740691.png" alt="image-20220126144740691" style="zoom:50%;float:left" />

<p>然后呢，我就买了一个HK的服务器，毕竟都不是小气的人。</p>
<p>2、登录机器</p>
<p>怎么登录服务器真的很傻瓜，没啥限制，在哪都能很快的ssh root@ip，直接在下面的页面上获取对应的信息，清晰明了。</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220126145033587.png" alt="image-20220126145033587" style="zoom:50%;float:left" />

<p>3、下载一个github项目(自己找好玩的项目啊)</p>
<p>我找的项目是：<a href="https://github.com/hwdsl2/setup-ipsec-vpn%EF%BC%8C%E8%87%B3%E4%BA%8E%E4%BD%A0%E6%89%BE%E5%95%A5%E9%9A%8F%E6%84%8F">https://github.com/hwdsl2/setup-ipsec-vpn，至于你找啥随意</a>~~</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://git.io/vpnquickstart -O vpn.sh &amp;&amp; sudo sh vpn.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会生成类似下面的信息，下面就可以直接使用IPsec连接了。 机器已经♻️，所以☺️~</span></span><br><span class="line">Server IP: 107.148.237.19</span><br><span class="line">IPsec PSK: E5ux2YRkHVN8LJv9XeGd</span><br><span class="line">Username: vpnuser</span><br><span class="line">Password: skcbn9ypy3UWwjch</span><br></pre></td></tr></table></figure>

<p>执行上面的命令完事，如果中途有依赖问题，百度即可解决。</p>
<p>4、测试：手机连接</p>
<p>详细文档：<a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/clients-zh.md#ios">https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/clients-zh.md#ios</a>  </p>
<p>亲测可用，接着就可以下载比如google浏览器之类的，然后愉快的学习。</p>
<p>5、惊喜：我发现啥也不限制，就是网速116KB/s，真的就只够一个看看视频，其他就不用奢望了。所以我决定退货。</p>
<p>6、退货：这里就不得不夸一夸服务态度，看见了吧，3小时回复速度，也不废话，说清楚了，直接给退货了。表示非常满意，要不是网速是在感人，我都不想退了。</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220126150158167.png" alt="image-20220126150158167" style="zoom:50%;float:left" />

<h3 id="背景2021-01-26-surfshark"><a href="#背景2021-01-26-surfshark" class="headerlink" title="背景2021-01-26-surfshark"></a>背景2021-01-26-surfshark</h3><p>1、上面的不是网速慢，我想着就不用服务器，直接买服务吧。于是，又是一通操作，确定了surfshark，至于为啥，网上都说surfshark=性价比，于是我就不争气的选择了这个，对比express<em>、norv</em> 还真是。</p>
<p>2、接着就是买服务，￥380 = 24月+2月，可以AliPay，其实还是很便宜的，不限速度+不限终端。</p>
<p>3、然后就按照官网折腾，surfshark + Open***(看官网)都不太行的。不管什么操作手势，都难以实现。</p>
<p>4、你以为我就放弃了，我确实是要放手了，然后我就开始搜索<code>退货</code>英文咋说。</p>
<p>5、这家是7*24h客服，于是我就English客服了，一顿说refund，然后我就收到好多配置文档PDF + 一个<code>config</code>,  注意这个config是我之前忽略的转机。</p>
<p>6、接着我就是按照PDF一顿操作，其实和官方视频没啥区别，没辙了就email support了，support说可以refund，但是能不能更详细的信息，我想着可以，就准备了一个notion文档。然后有开始等，感觉7*24h也很慢，人家睡觉的时候还是要等。</p>
<p>7、我就想要好好理解下我到底是买了一个啥，后面吭哧吭哧发现，我还需要一个proxy，就是设置各种路由规则的。比如百度就不同代理，需要proxy的就proxy。</p>
<p>8、我就github上学习了一会，有学习了两个新项目：</p>
<p><a href="https://github.com/yichengchen/clashX">https://github.com/yichengchen/clashX</a></p>
<p><a href="https://github.com/Dreamacro/clash">https://github.com/Dreamacro/clash</a></p>
<p><a href="https://github.com/txthinking/brook">https://github.com/txthinking/brook</a> ：在ios上有app</p>
<p>9、接着我就安装了一个小猫猫软件 = Surge(好用但是贵的哟)</p>
<p>还记得English客服小姐姐给了我一个Config文件(直接练习客服说要config文件，提供的app在**不能用)，这个时候就是发挥作用了，打开配置文件，直接将配置塞进去，就可以玩了。</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20220126152837014.png" alt="image-20220126152837014" style="zoom:50%;float:left" />

<p>10、你以为Brook是你想下载就能下载，这个时候你需要一个对应的美区的apple id，这个就不废话了，因为本人提供免费的支持😁，请联系。</p>
]]></content>
      <tags>
        <tag>腾讯云</tag>
        <tag>ECS</tag>
        <tag>RAKsmart</tag>
      </tags>
  </entry>
  <entry>
    <title>本地调试proxysql</title>
    <url>/2021/12/29/%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95proxysql/</url>
    <content><![CDATA[<h4 id="1-构建镜像"><a href="#1-构建镜像" class="headerlink" title="1. 构建镜像"></a>1. 构建镜像</h4><p>Dockerfile + 构建镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">&quot;Container for dev &amp; debug&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y automake bzip2 cmake make gcc-c++ gcc git openssl openssl-devel gnutls gnutls-devel libtool patch openssh-server perl-IPC-Cmd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y gdb-gdbserver <span class="built_in">which</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置ssh服务</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;PermitRootLogin yes&#x27;</span> &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&#x27;PermitEmptyPasswords yes&#x27;</span> &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&#x27;PasswordAuthentication yes&#x27;</span> &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&#x27;root:root&#x27;</span> | chpasswd &amp;&amp; \</span></span><br><span class="line"><span class="bash">    ssh-keygen -A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span> </span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/usr/sbin/sshd&quot;</span>, <span class="string">&quot;-D&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t proxysqldebug:v1 .</span><br></pre></td></tr></table></figure>

<h4 id="2-运行容器"><a href="#2-运行容器" class="headerlink" title="2. 运行容器"></a>2. 运行容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 2222:22 --security-opt seccomp:unconfined -v $PWD:/home/luzhangting001/proxysql --name proxysqldev proxysqldebug:v1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后面容器stop + start 不要在重启，如下图</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20211229121528631.png" alt="image-20211229121528631" style="zoom:100%; float:left" />

<h4 id="3-启动debug"><a href="#3-启动debug" class="headerlink" title="3. 启动debug"></a>3. 启动debug</h4><p>配置launch.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;/home/luzhangting001/proxysql/src/proxysql&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;--foreground&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--debug&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--config&quot;</span>,</span><br><span class="line">            <span class="string">&quot;/home/luzhangting001/proxysql/src/proxysql.cfg&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--initial&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;/home/luzhangting001/proxysql&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;pipeTransport&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;debuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;pipeProgram&quot;</span>: <span class="string">&quot;/usr/bin/ssh&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;pipeArgs&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;root@localhost&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-p&quot;</span>,</span><br><span class="line">                <span class="string">&quot;2222&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;pipeCwd&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;sourceFileMap&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;/home/luzhangting001/proxysql&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>启动报错：因为之前弄过，ssh报错了</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20211229121827990.png" alt="image-20211229121827990" style="zoom:100%; float:left" />

<p>将known_hosts里面的相关信息删除, 其实我不知道是不是必须这么做，可能不是必须的</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20211229122615654.png" alt="image-20211229122615654" style="zoom:100%; float:left" />

<p>将本机的公钥上传</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -p 2222 root@localhost</span><br></pre></td></tr></table></figure>

<p>vscode里面启动</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20211229153334425.png" alt="image-20211229153334425" style="zoom:80%;float:left" />
]]></content>
      <tags>
        <tag>proxysql</tag>
        <tag>mac本地环境</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora写blog中粘贴图片自动上传图床</title>
    <url>/2021/12/24/blog%E5%9B%BE%E5%BA%8A%E7%AF%87/</url>
    <content><![CDATA[<h4 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h4><p>我电脑上 cmd + trl + a(微信截图) -&gt; 来到Typora(cmd + v) 粘贴。</p>
<p>然后就自动帮我上传图床，并且替换成图床照片吧，这样我也不需要切换到图床上去捣鼓了，就专注在Typora上去打字。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>图床：<a href="https://blog.svend.cc/upic/tutorials/github/">github</a>、<a href="https://blog.svend.cc/upic/tutorials/gitee/">gitee</a>，我自己比较常用的是路过图床，但是uPic不会配置，那就算啦，佛系找个能成功的。</p>
<blockquote>
<p>采坑：github图片可以正常上传，但是展示出来</p>
</blockquote>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20211225084632762.png" alt="image-20211225084632762" style="zoom:30%;float:left" />

<p>因此，我们还好折腾Gitee配置。</p>
<ol>
<li><p>创建仓库</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20211225085435762.png" alt="image-20211225085435762" style="zoom:25%;float:left" />

<ol start="2">
<li>生成私人令牌</li>
</ol>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20211225083650340.png" alt="image-20211225083650340" style="zoom:25%;float:left" />

<ol start="3">
<li><p>配置uPic</p>
<p>uPic直接github上下载了安装好，然后按照下面的方法配置</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20211225090108133.png" alt="image-20211225090108133" style="zoom:25%;float:left" /></li>
<li><p>配置Typora</p>
<p>cmd+,打开软件偏好设置,成功了之后就在写blog的时候直接截图+粘贴吧，巴斯的很~</p>
<img src="https://gitee.com/zhangtinglu/blog_pic/raw/master/uPic/image-20211225090323825.png" alt="image-20211225090323825" style="zoom:25%;float:left" /></li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>Typora</tag>
        <tag>图片粘贴</tag>
        <tag>上传图床</tag>
      </tags>
  </entry>
  <entry>
    <title>hashicorp-raft源码系列-4-leader逻辑</title>
    <url>/2021/12/20/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-4-leader%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<p>前面三篇我们分别介绍了Raft的API、网络层、存储层，从这一篇开始我们来看Raft的<code>Leader、Candidate、Follower</code>实现。</p>
<h4 id="r-runLeader逻辑"><a href="#r-runLeader逻辑" class="headerlink" title="r.runLeader逻辑"></a>r.runLeader逻辑</h4><p>事务提交的过程：接着我们一点点分析，</p>
<h5 id="发送请求，Apply方法"><a href="#发送请求，Apply方法" class="headerlink" title="发送请求，Apply方法"></a>发送请求，Apply方法</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Apply</span></span><br><span class="line"><span class="comment">//  -&gt; ApplyLog</span></span><br><span class="line"><span class="comment">// 写的时候也不需要返回什么，主要就是Check Error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">ApplyLog</span><span class="params">(log Log, timeout time.Duration)</span> <span class="title">ApplyFuture</span></span> &#123;</span><br><span class="line">  logFuture := &amp;logFuture&#123;</span><br><span class="line">    log: Log&#123;</span><br><span class="line">      Type:       LogCommand,</span><br><span class="line">      Data:       log.Data,</span><br><span class="line">      Extensions: log.Extensions,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  logFuture.init()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 这个写法很有意思，到底是什么意思呢？放到applyCh马上返回，这个时候return logFuture不一定有数据的吧，client怎么判断操作是成功还是失败呢。</span></span><br><span class="line">  <span class="keyword">case</span> r.applyCh &lt;- logFuture:</span><br><span class="line">    <span class="keyword">return</span> logFuture</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="runLeader"><a href="#runLeader" class="headerlink" title="runLeader()"></a>runLeader()</h5><p>接着我们看下leader初始化的时候会干些啥，重点看下初始化的后台处理协程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">runLeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// ?? leaderCh这个chan还真的是不知道干啥的，后面有时间在重点看下</span></span><br><span class="line">  overrideNotifyBool(r.leaderCh, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup leader state，主要是节点的信息</span></span><br><span class="line">  r.setupLeaderState()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义清理逻辑</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重点：为每一个peer启动一个Log复制协程，</span></span><br><span class="line">  r.startStopReplication()</span><br><span class="line">  <span class="comment">//  调用-&gt; r.goFunc(func() &#123; r.replicate(s) &#125;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始leader循环</span></span><br><span class="line">  r.leaderLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Leader消费r-applyCh"><a href="#Leader消费r-applyCh" class="headerlink" title="Leader消费r.applyCh"></a>Leader消费r.applyCh</h5><p>将客户端的写凑成一批，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> newLog := &lt;-r.applyCh:</span><br><span class="line">  <span class="comment">// Group commit, 组提交</span></span><br><span class="line">  ready := []*logFuture&#123;newLog&#125;</span><br><span class="line">GROUP_COMMIT_LOOP:</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r.config().MaxAppendEntries; i++ &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> newLog := &lt;-r.applyCh:</span><br><span class="line">      ready = <span class="built_in">append</span>(ready, newLog)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span> GROUP_COMMIT_LOOP</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dispatch the logs</span></span><br><span class="line">  <span class="keyword">if</span> stepDown &#123;</span><br><span class="line">     ....</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r.dispatchLogs(ready)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接着看看dispatchLogs逻辑</p>
<p>加r.leaderState.inflight list, 表示需要处理的applyLogs</p>
<p>日志持久化 r.logs.StoreLogs(logs)，类比mysql 持久化redo log</p>
<p>将自己的log index往前，并且通知<code>commitCh</code></p>
<p>持久化lastIndex，r.setLastLog(lastIndex, term)</p>
<p>通知每个replication新Log –  asyncNotifyCh(f.triggerCh)  </p>
<p>接着就是上面的初始化的时候干的事情了，给每个channel发消息</p>
<p>想想哪些是异步的？为啥要异步处理呢？</p>
<p>搞清楚重点</p>
<p>下面的<code>observe</code>是干啥的？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.observe(LeaderObservation&#123;Leader: leader&#125;)</span><br></pre></td></tr></table></figure>

<p>client 写请求 :api.go   Apply方法，返回一个ApplyFuture对象，包含req、response、error</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>–&gt;  发消息 append entity –&gt; 多数派的回复  – &gt; 客户端返回  –&gt; 应用FSM(另一个流程)–&gt; 通知其他节点可以应用 –</p>
<p>client返回的标准是啥？日志多数派 or  Master apply成功(不可能)   </p>
<p>认真琢磨其中的优化</p>
<h4 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h4><p>1、chan里面只有一个元素，并且不能并发调用。下面代码的理解，到底是怎么避免并发调用的？还有别的实现吗？这个实现是不是有点trick？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overrideNotifyBool</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">bool</span>, v <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> ch &lt;- v:</span><br><span class="line">    <span class="comment">// value sent, all done</span></span><br><span class="line">  <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="comment">// channel had an old value</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- v:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;race: channel was sent concurrently&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<code>leaderLoop</code>这个里面全是异步的chan，代码规划的非常好，很值得学习</p>
]]></content>
      <tags>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>hashicorp:raft源码系列(3)--存储层</title>
    <url>/2021/12/17/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-3-%E5%AD%98%E5%82%A8%E5%B1%82/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>接着上一篇我们讲了网络层，接下来我们来讲<code>LogStore、StableStore、FSM、SnapshotStore</code>，为啥这些一起讲呢，因为这些都是存储相关，并且功能相对简单，并没有像<code>Transport</code>那样有<code>NetworkTransport</code>实现可以用来进行分析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(conf *Config, fsm FSM, logs LogStore, stable StableStore, snaps SnapshotStore, trans Transport)</span> <span class="params">(*Raft, error)</span></span> &#123;     	......&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StableStore"><a href="#StableStore" class="headerlink" title="StableStore"></a>StableStore</h4><p>这个组件主要就是为了安全考虑而存在的，提供一个可以持久化k-v的存储的即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StableStore <span class="keyword">interface</span> &#123;</span><br><span class="line">  Set(key []<span class="keyword">byte</span>, val []<span class="keyword">byte</span>) error</span><br><span class="line">  Get(key []<span class="keyword">byte</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uint64是日志号和任期定义的类型，方便存</span></span><br><span class="line">  SetUint64(key []<span class="keyword">byte</span>, val <span class="keyword">uint64</span>) error</span><br><span class="line">  GetUint64(key []<span class="keyword">byte</span>) (<span class="keyword">uint64</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="LogStore"><a href="#LogStore" class="headerlink" title="LogStore"></a>LogStore</h4><p>这个组件就是为了存日志的，比如用户发过来<code>set a=1</code>, 将这个存起来即可。和上面的<code>StableStore</code>能力是同一种，不过日志可能比较多，需要根据实现情况进行选择。项目在测试的时候实现了一个<code>inmem</code>的日志存储，用了一个<code>map</code>来进行存储。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inmem模拟，直接map存，基本能力-读写。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInmemStore</span><span class="params">()</span> *<span class="title">InmemStore</span></span> &#123;</span><br><span class="line">  i := &amp;InmemStore&#123;</span><br><span class="line">    logs:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint64</span>]*Log),</span><br><span class="line">    kv:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>),</span><br><span class="line">    kvInt: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="FSM"><a href="#FSM" class="headerlink" title="FSM"></a>FSM</h4><p>FMS的功能，②+③不是Raft的核心逻辑。Raft启动时候会有一个后台协程<code>runFSM</code>负责来做下面的三件事，Main线程将应用日志请求放到<code>fsmMutateCh</code>里面，将打快照的请求放到<code>fsmSnapshotCh</code>里面，不阻塞Main</p>
<p>① 应用日志，raft log多数派已经确认，就可以应用到底层存储了。</p>
<p>② 快照</p>
<p>③ 节点恢复</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FSM <span class="keyword">interface</span> &#123;</span><br><span class="line">  Apply(*Log) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  Snapshot() (FSMSnapshot, error)</span><br><span class="line">  Restore(io.ReadCloser) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">runFSM</span><span class="params">()</span></span> &#123;</span><br><span class="line">  commitSingle := <span class="function"><span class="keyword">func</span><span class="params">(req *commitTuple)</span></span>&#123;...&#125;</span><br><span class="line">  commitBatch := <span class="function"><span class="keyword">func</span><span class="params">(reqs []*commitTuple)</span></span>&#123;...&#125;</span><br><span class="line">  restore := <span class="function"><span class="keyword">func</span><span class="params">(req *restoreFuture)</span></span>&#123;...&#125;</span><br><span class="line">  snapshot := <span class="function"><span class="keyword">func</span><span class="params">(req *reqSnapshotFuture)</span></span>&#123;...&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ptr := &lt;-r.fsmMutateCh:</span><br><span class="line">      <span class="keyword">switch</span> req := ptr.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> []*commitTuple:</span><br><span class="line">        commitBatch(req)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> *restoreFuture:</span><br><span class="line">        restore(req)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;bad type passed to fsmMutateCh: %#v&quot;</span>, ptr))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> req := &lt;-r.fsmSnapshotCh:</span><br><span class="line">      snapshot(req)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> &lt;-r.shutdownCh:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>snapshot不是重点，所以先简单介绍下，后续重读的时候补上这一模块。下一篇我们来看最重要的Raft的逻辑。</p>
]]></content>
      <tags>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>blog折腾记录</title>
    <url>/2021/12/17/blog%E9%83%A8%E7%BD%B2%E7%AF%87/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近开始重拾写blog的习惯，想着坚持点啥吧。</p>
<p>结果将github上的网站打开，2020-03最近一篇，现在可是2021-12月了，搁置了1年9个月，真行。</p>
<p>然后打算上传一篇blog，发现新电脑上环境也没有了。大脑开始高速运转，好吧~ 完全没有一点映像。</p>
<p>因此，打算乖乖的写文章记录，好记性不如烂笔头，先人们不曾欺我啊~</p>
<h4 id="操作记录"><a href="#操作记录" class="headerlink" title="操作记录"></a>操作记录</h4><p>之前还折腾什么mweb，一键部署多个平台啥的。现在可能是思想观念变了，内容平台还是以内容为主。既然都花了那么多心思写了，难道还不能去各个平台溜达一圈导入下吗。</p>
<h5 id="用什么写？"><a href="#用什么写？" class="headerlink" title="用什么写？"></a>用什么写？</h5><blockquote>
<p>Typero</p>
</blockquote>
<h5 id="用什么图床？"><a href="#用什么图床？" class="headerlink" title="用什么图床？"></a>用什么图床？</h5><blockquote>
<p> 路过图床。就是觉得剪贴板直接ctrl+v很方便，懒得换。</p>
</blockquote>
<h5 id="发布到哪"><a href="#发布到哪" class="headerlink" title="发布到哪"></a>发布到哪</h5><p>原则就是支持MD导入</p>
<ul>
<li>github，可以去百度智能云上去申请一个域名，便宜的一年就13元，不过续费比较贵☺️。 –  算了，实名认证啥的麻烦。</li>
<li>csdn</li>
<li>cnblog(不支持MD导入，有点愁人)</li>
<li>简书(不支持MD导入，放弃)</li>
</ul>
<h5 id="hexo与github配置"><a href="#hexo与github配置" class="headerlink" title="hexo与github配置"></a>hexo与github配置</h5><p>说起来我之前弄过一版，但是完成忘记了。更惨的是git仓库的东西都不知道怎么复用，只能完全重来，就当是一个新的开始好了。</p>
<p>先将一次性的操作做了，安装&amp;配置。配置文件只有2个，一定要做好备份</p>
<p>_config.yml: 网站配置</p>
<p>themes/next/_config.yml：主题配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mac上安装hexo</span></span><br><span class="line">brew install hexo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化项目</span></span><br><span class="line">hexo init myblog</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> next主题</span></span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定制化配置 _config.yml</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># site： 这力的language要和主题里面的themes/next/languages下面的文件能对应才行</span></span></span><br><span class="line">title: Moonshine&#x27;s Blog</span><br><span class="line">subtitle: &#x27;日拱一卒无有尽，功不唐捐终入海&#x27;</span><br><span class="line">description: &#x27;風が吹いて葉が落ち、落ち葉は土壌の肥やしとなり土壌を肥えさせ、果物がゆっくりと着実に育つのです&#x27;</span><br><span class="line">keywords: &#x27;数据库&#x27;</span><br><span class="line">author: Moonshine</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># url</span></span></span><br><span class="line">url: https://zhangtinglu.github.io/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 主题</span></span></span><br><span class="line">theme: next</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 部署git</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repo: &#x27;https://github.com/zhangtinglu/zhangtinglu.github.io&#x27;</span><br><span class="line">  branch: &#x27;master&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 代码语法高亮，将prismjs改成true就行了</span></span></span><br><span class="line">prismjs:</span><br><span class="line">  enable: true </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定制theme配置 themes/next/_config.yml -- 有点多，直接备份吧</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把自己需要的需要的page安装下</span></span><br><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 首页摘要 -- 太费劲了，直接用归档页面当成主页</span></span><br><span class="line">~/myblog/themes/next/layout </span><br><span class="line">mv index.swig index_bak.swig</span><br><span class="line">cp archive.swig index.swig</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 代码可折叠 - 收缩</span></span><br><span class="line">codeblock:</span><br><span class="line">  highlight_theme: night</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显得太大了 -- 不管能看就行</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文章目录</span></span><br><span class="line">toc:</span><br><span class="line">  expand_all: true</span><br></pre></td></tr></table></figure>

<p>接着就是平常使用了，创建blog-deploy</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先将hello world这个page删除</span></span><br><span class="line">rm -rf /source/_posts/hello-world.md</span><br><span class="line">hexo new &#x27;blog&#x27;</span><br><span class="line">hexo s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署</span></span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>真的前端做到最后会疯，太容易产生强迫症了。</p>
<p>啥也不说了，重复性劳动，如果换个电脑，直接将整个项目备份。</p>
]]></content>
      <tags>
        <tag>hexo配置</tag>
      </tags>
  </entry>
  <entry>
    <title>hashicorp:raft源码系列(2)--网络层</title>
    <url>/2021/12/17/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-2-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>接着上面–导读，本篇讲解Transport传输层实现。</p>
<p>如下NewRaft函数的参数中，除了Config结构，其他都是以interface形式实现。</p>
<p>接下来几篇我们分别对这5类接口进行详细分析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(conf *Config, fsm FSM, logs LogStore, stable StableStore, snaps SnapshotStore, trans Transport)</span> <span class="params">(*Raft, error)</span></span> &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="传输层涉及哪些文件"><a href="#传输层涉及哪些文件" class="headerlink" title="传输层涉及哪些文件"></a>传输层涉及哪些文件</h4><ul>
<li><p>transport.go: 定义传输层接口，下图中的Transport Interface对象。</p>
</li>
<li><p>inmem_transport.go: 以内存的方式实现Transport接口，用于测试。</p>
</li>
<li><p>net_transport.go: 网络方式实现Transport接口。</p>
</li>
<li><p>tcp_transport.go: 以TCP的方式实现了NetworkTransport需要的SteamLayer。</p>
</li>
<li><p>command.go：这个文件里面定义了各种RPC request和response的结构，eg: AppendEntriesRequest、AppendEntriesResponse</p>
<p><a href="https://imgtu.com/i/ovlYo6"><img src="https://s4.ax1x.com/2021/12/14/ovlYo6.png" alt="ovlYo6.png"></a></p>
</li>
</ul>
<p>总结，NetworkTransport和InmemTransport是对Transport层的具体实现，接下来我们对NetworkTransport进行详细分析。</p>
<h4 id="传输层具体是怎么实现的呢？"><a href="#传输层具体是怎么实现的呢？" class="headerlink" title="传输层具体是怎么实现的呢？"></a>传输层具体是怎么实现的呢？</h4><h5 id="从测试用例TestNetworkTransport-AppendEntries开始"><a href="#从测试用例TestNetworkTransport-AppendEntries开始" class="headerlink" title="从测试用例TestNetworkTransport_AppendEntries开始"></a>从测试用例TestNetworkTransport_AppendEntries开始</h5><p>测试用例一般能告诉我们怎么玩，而AppendEntries发送日志又是最常用的功能。因此，我们就从这里开始。</p>
<p><a href="https://imgtu.com/i/ovW3X4"><img src="https://s4.ax1x.com/2021/12/14/ovW3X4.md.png" alt="ovW3X4.md.png"></a></p>
<ol>
<li><p>初始化消费者(trans1)，这一步后面是要详细看的，所以我们标星。</p>
</li>
<li><p>启动消费者，监听rpcCh，也就是Consumer()返回的只读channel。🤔：rpc.Respond函数只是给respCh添加了一个元素，那谁来消费这个元素呢？</p>
</li>
<li><p>初始化生产者( trans2)，同样使用newTCPTransport实现。</p>
</li>
<li><p>调用AppendEntries消息给消费者trans1，这里直接就获取返回了。为啥看着就是同步返回的呢? 按理说网络调用一般都是异步返回吧。这个星标步骤，我们后面来详细分析。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNetworkTransport_AppendEntries</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, useAddrProvider := <span class="keyword">range</span> []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>&#125; &#123;</span><br><span class="line">    <span class="comment">// ①初始化trans1 -- 消费者</span></span><br><span class="line">    trans1, err := makeTransport(t, useAddrProvider, <span class="string">&quot;localhost:0&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    rpcCh := trans1.Consumer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义测试使用的RPC请求</span></span><br><span class="line">    args := AppendEntriesRequest&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    resp := AppendEntriesResponse&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 启动消费者监听 </span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> rpc := &lt;-rpcCh:</span><br><span class="line">        <span class="comment">// 获取消息然后返回，注意Respond函数只是给RPC对象的RespChan添加一个值，那么谁来消费这和chan呢</span></span><br><span class="line">        rpc.Respond(&amp;resp, <span class="literal">nil</span>)</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③ 初始化生产者 trans2</span></span><br><span class="line">    trans2, err := makeTransport(t, useAddrProvider, <span class="keyword">string</span>(trans1.LocalAddr()))</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ④ 发送AppendEntries消息给trans1，这里直接就获取返回了。为啥看着就是同步返回的呢</span></span><br><span class="line">    <span class="keyword">if</span> err := trans2.AppendEntries(<span class="string">&quot;id1&quot;</span>, trans1.LocalAddr(), &amp;args, &amp;out); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      t.Fatalf(<span class="string">&quot;err: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="makeTransport实现分析"><a href="#makeTransport实现分析" class="headerlink" title="makeTransport实现分析"></a>makeTransport实现分析</h5><ol>
<li><p>先看下函数调用关系</p>
<p>newTCPTransport：就是tcp端口绑定，生成TCPStreamLayer(上面的类图中知道是NetworkTransport结构需要的成员)</p>
<p>NewNetworkTransportWithConfig：创建NetworkTransport对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   makeTransport</span><br><span class="line">   -&gt; NewTCPTransportWithConfig</span><br><span class="line">     -&gt; newTCPTransport <span class="comment">// 负责进行tcp端口绑定，生成TCPStreamLayer，包装器</span></span><br><span class="line">   		-&gt; NewNetworkTransportWithConfig <span class="comment">// 真正创建NetworkTransport对象</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> newTCPTransport</span><br><span class="line"></span><br><span class="line">   下面是newTCPTransport的实现，最后transportCreator就是网络层的创建器</span><br><span class="line"></span><br><span class="line">   <span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">   // ① 调用net库绑定tcp监听端口</span></span><br><span class="line"><span class="string">   list, err := net.Listen(&quot;tcp&quot;, bindAddr)</span></span><br><span class="line"><span class="string">   // ② 将TCPListener -&gt; TCPStreamLayer(上面的类图中NetworkTransport需要实现StreamLayer接口)</span></span><br><span class="line"><span class="string">   stream := &amp;TCPStreamLayer&#123;</span></span><br><span class="line"><span class="string">   		advertise: advertise,</span></span><br><span class="line"><span class="string">   		listener:  list.(*net.TCPListener),</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   // ③ 将上面的 TCPStreamLayer-&gt; NetworkTransport，调用 NewNetworkTransportWithConfig</span></span><br><span class="line"><span class="string">   trans := transportCreator(stream)</span></span><br></pre></td></tr></table></figure></li>
<li><p>newNetworkTransport</p>
<p>下面是创建网络层的代码，一个Acceptor专门用来accetor连接，每个新的连接都会创建一个协程进行处理。</p>
<p><a href="https://imgtu.com/i/T9BOV1"><img src="https://s4.ax1x.com/2021/12/16/T9BOV1.png" alt="T9BOV1.png"></a></p>
<ul>
<li><p>Main线程调用trans.listen()启动监听协程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ① 将上面的config注入进来，主要是Stream</span></span><br><span class="line">trans := &amp;NetworkTransport&#123;</span><br><span class="line">    connPool:              <span class="built_in">make</span>(<span class="keyword">map</span>[ServerAddress][]*netConn),</span><br><span class="line">    consumeCh:             <span class="built_in">make</span>(<span class="keyword">chan</span> RPC),</span><br><span class="line">    logger:                config.Logger,</span><br><span class="line">    maxPool:               config.MaxPool,</span><br><span class="line">    shutdownCh:            <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    stream:                config.Stream,</span><br><span class="line">    timeout:               config.Timeout,</span><br><span class="line">    TimeoutScale:          DefaultTimeoutScale,</span><br><span class="line">    serverAddressProvider: config.ServerAddressProvider,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ② 设置Stream上下文</span></span><br><span class="line">trans.setupStreamContext()</span><br><span class="line"><span class="comment">// ③ 启动一个后台线程，专门来处理连接</span></span><br><span class="line"><span class="keyword">go</span> trans.listen()</span><br></pre></td></tr></table></figure></li>
<li><p>Acceptor监听新连接，并启动处理协程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">listen</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ① 接收新连接，这个底层是epoll实现，</span></span><br><span class="line">    conn, err := n.stream.Accept()</span><br><span class="line">    <span class="comment">// ② 启动处理协程</span></span><br><span class="line">    <span class="keyword">go</span> n.handleConn(n.getStreamContext(), conn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对连接进行处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">handleConn</span><span class="params">(connCtx context.Context, conn net.Conn)</span></span> &#123;</span><br><span class="line">  r := bufio.NewReaderSize(conn, connReceiveBufferSize)</span><br><span class="line">  w := bufio.NewWriter(conn)</span><br><span class="line">  dec := codec.NewDecoder(r, &amp;codec.MsgpackHandle&#123;&#125;)</span><br><span class="line">  enc := codec.NewEncoder(w, &amp;codec.MsgpackHandle&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ① 读数据 -- 解码 -- 处理 -- 编码</span></span><br><span class="line">    <span class="keyword">if</span> err := n.handleCommand(r, dec, enc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ② 返回</span></span><br><span class="line">    <span class="keyword">if</span> err := w.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handleCommand是核心的处理逻辑，这里通过chan让用户使用的时候感觉是同步的。</p>
<ol>
<li><p>获取类型ReadByte，约定第一位表示的RPC类型，eg:AppendEntries RequestVote</p>
</li>
<li><p>定义respCh。</p>
</li>
<li><p>对不同类型的Request进行解码。</p>
</li>
<li><p>将解码出来的RPC消息放到消费channel中</p>
</li>
<li><p>等respCh返回处理后的结构</p>
</li>
<li><p>将结构进行编码。</p>
<p>下面是和别的协程进行交互的方式，实际上处理逻辑是外包出去进行处理的。</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/T9R9Hg"><img src="https://s4.ax1x.com/2021/12/16/T9R9Hg.png" alt="T9R9Hg.png"></a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">handleCommand</span><span class="params">(r *bufio.Reader, dec *codec.Decoder, enc *codec.Encoder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  getTypeStart := time.Now()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ① 获取类型，约定第一位表示的RPC类型，eg:AppendEntries RequestVote</span></span><br><span class="line">  rpcType, err := r.ReadByte()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ② 定义respCh</span></span><br><span class="line">  respCh := <span class="built_in">make</span>(<span class="keyword">chan</span> RPCResponse, <span class="number">1</span>)</span><br><span class="line">  rpc := RPC&#123;</span><br><span class="line">    RespChan: respCh,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ③ 对不同类型的Request进行解码</span></span><br><span class="line">  <span class="keyword">switch</span> rpcType &#123;</span><br><span class="line">  <span class="keyword">case</span> rpcAppendEntries:</span><br><span class="line">    <span class="keyword">var</span> req AppendEntriesRequest</span><br><span class="line">    <span class="keyword">if</span> err := dec.Decode(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    rpc.Command = &amp;req</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> rpcRequestVote:</span><br><span class="line">    <span class="keyword">var</span> req RequestVoteRequest</span><br><span class="line">    <span class="keyword">if</span> err := dec.Decode(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    rpc.Command = &amp;req</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ④ 将解码出来的灌到Raft.consumeCh</span></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> n.consumeCh &lt;- rpc:</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⑤ 等结果，上面的consumeCh被Raft的runLeader之类的其他协程进行处理后，将结果塞会到respCh。</span></span><br><span class="line">RESP:</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> resp := &lt;-respCh:</span><br><span class="line">    <span class="comment">// ⑥ 对结果进行编码</span></span><br><span class="line">    <span class="keyword">if</span> err := enc.Encode(resp.Response); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="AppendEntries实现分析"><a href="#AppendEntries实现分析" class="headerlink" title="AppendEntries实现分析"></a>AppendEntries实现分析</h5><p>上面的传输层已经创建好了连接的处理器(消费者)，现在需要消息的生产者，AppendEntries就能充当这一角色。</p>
<p>需要网络交互的RequestVote、AppendEntries、TimeoutNow都是调用的genericRPC实现的，genericRPC是真正执行请求的函数。</p>
<p><a href="https://imgtu.com/i/ovxupF"><img src="https://s4.ax1x.com/2021/12/14/ovxupF.png" alt="ovxupF.png"></a></p>
<p>下面是一个genericRPC的流程：</p>
<p>① 从连接池获取连接对象，简单的维护了一个连接池。</p>
<p>② 在连接上发送RPC请求。</p>
<p>③ 解码Response，将conn返还连接池如果可以的话。</p>
<blockquote>
<p>注意：这里发送请求之后，同步获取Response。如果是短链接，为了高效就不会直接在这里等结果了。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">genericRPC</span><span class="params">(id ServerID, target ServerAddress, rpcType <span class="keyword">uint8</span>, args <span class="keyword">interface</span>&#123;&#125;, resp <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// ① 从连接池中获取连接，NetworkTransport维护了一个连接池</span></span><br><span class="line">  conn, err := n.getConnFromAddressProvider(id, target)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ② 发送RPC请求</span></span><br><span class="line">  <span class="keyword">if</span> err = sendRPC(conn, rpcType, args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ③ 解码Response，并且归还连接。注意：这里发送了请求之后，马上就解码Response了。想想我们的mysql客户端，(发消息,等结果），不可以一直发消息而不接收。</span></span><br><span class="line">  canReturn, err := decodeResponse(conn, resp)</span><br><span class="line">  <span class="keyword">if</span> canReturn &#123;</span><br><span class="line">    n.returnConn(conn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们对比看看InmemTransport.makeRPC方法来体会其中的不同，这边获取结果需要从respCh读取。那么，这个Response是谁塞进去respCh的呢，毕竟我们只是获取了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *InmemTransport)</span> <span class="title">makeRPC</span><span class="params">(target ServerAddress, args <span class="keyword">interface</span>&#123;&#125;, r io.Reader, timeout time.Duration)</span> <span class="params">(rpcResp RPCResponse, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义交互用的RPC对象</span></span><br><span class="line">  req := RPC&#123;</span><br><span class="line">    Command:  args,</span><br><span class="line">    Reader:   r,</span><br><span class="line">    RespChan: respCh,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 发送消息，直接将构造出来的req灌到peer.consumerCh消费channel，本来就是内存中的对象。</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> peer.consumerCh &lt;- req:</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 等respCh结果，消费协程把RPC拿出来-处理-结果塞回到respCh。</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> rpcResp = &lt;-respCh:</span><br><span class="line">      <span class="keyword">if</span> rpcResp.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">         err = rpcResp.Error</span><br><span class="line">      &#125;</span><br><span class="line">     .... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：</p>
<p>1、上面的实现是一条一条的发，实际上为了高效，我们往往都是批处理的。</p>
<p>2、想RequestVote要给多个对象发投票消息，那么肯定不会发一个消息等一个结果，而是群发，然后处理结构。</p>
<h5 id="AppendEntriesPipeline实现"><a href="#AppendEntriesPipeline实现" class="headerlink" title="AppendEntriesPipeline实现"></a>AppendEntriesPipeline实现</h5><p>同样的我们从测试用例开始，看看批处理是怎么玩的。主要看看批处理和单条处理的区别。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化AppendEntriesPipeline对象，启动协程处理 inprogressCh -&gt; doneCh</span></span><br><span class="line">pipeline, err := trans2.AppendEntriesPipeline(<span class="string">&quot;id1&quot;</span>, trans1.LocalAddr())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发10个消息，并且将RPC加入到inprogressCh</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  out := <span class="built_in">new</span>(AppendEntriesResponse)</span><br><span class="line">  <span class="keyword">if</span> _, err := pipeline.AppendEntries(&amp;args, out); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.Fatalf(<span class="string">&quot;err: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer()会返回doneCh，从doneCh获取数据，发了10个消息，所以需要获取10次结果</span></span><br><span class="line">respCh := pipeline.Consumer()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ready := &lt;-respCh:</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是发消息的时候  非pipeline VS pipeline的区别</p>
<p><a href="https://imgtu.com/i/TCM7Us"><img src="https://s4.ax1x.com/2021/12/16/TCM7Us.md.png" alt="TCM7Us.md.png"></a></p>
<p>下面是解码消息的时候  非pipeline VS pipeline的区别，pipeline的decodeResponses方法是初始化AppendEntriesPipeline对象的时候就启动的协程。</p>
<p><a href="https://imgtu.com/i/TClAFs"><img src="https://s4.ax1x.com/2021/12/16/TClAFs.md.png" alt="TClAFs.md.png"></a></p>
<p>这里有一个❓疑问关于net.Conn的 A-&gt;B-&gt;A，这个过程在网络上是两边可以同时发送数据吗？为啥上面的非pipeline模式，send之后马上就可以decode消息了，conn这里帮我们做了什么。</p>
<p>批处理的整体实现就是，启动一个协程监控inprogress的任务。然后开发批量的发消息，比如一次发10条，然后inprogress协程被激活，开始处理。将处理的结果放到doneCh，最后用户从doneCh获取消息即可。</p>
<h5 id="RequestVote过程"><a href="#RequestVote过程" class="headerlink" title="RequestVote过程"></a>RequestVote过程</h5><p>上面我们分析了一对一pipeline发消息，下面我们来看看1:N，在集群里面给所有人发消息，并且处理结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">electSelf</span><span class="params">()</span> &lt;-<span class="title">chan</span> *<span class="title">voteResult</span></span> &#123;</span><br><span class="line">  <span class="comment">// ① 创建一个包含peers数量的respCh</span></span><br><span class="line">  respCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *voteResult, <span class="built_in">len</span>(r.configurations.latest.Servers))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ② 并发发消息，然后将结果灌回到respCh。后面从respCh获取投票结果即可进行处理。</span></span><br><span class="line">  askPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer Server)</span></span> &#123;</span><br><span class="line">    r.goFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      resp := &amp;voteResult&#123;voterID: peer.ID&#125;</span><br><span class="line">      err := r.trans.RequestVote(peer.ID, peer.Address, req, &amp;resp.RequestVoteResponse)</span><br><span class="line">      ... </span><br><span class="line">      respCh &lt;- resp</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> respCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结🤔"><a href="#总结🤔" class="headerlink" title="总结🤔"></a>总结🤔</h4><p>网络是一个很复杂的模块，后续可以看看比较经典的Redis、Nginx这些优秀组件的实现。</p>
<p>ProxySQL：惊群效应思考</p>
]]></content>
      <tags>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>hashicorp:raft源码系列(1)--导读</title>
    <url>/2021/12/17/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-1-%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="Raft是干啥的？"><a href="#Raft是干啥的？" class="headerlink" title="Raft是干啥的？"></a>Raft是干啥的？</h3><p><a href="http://thesecretlivesofdata.com/raft/">动画说明</a></p>
<p>简述如下图：用户SET 5，3个不同节点都能获取SET 5的操作。所谓的最简单的分布式一致性。</p>
<p><a href="https://imgtu.com/i/oO3r0P"><img src="https://s4.ax1x.com/2021/12/13/oO3r0P.png" alt="oO3r0P.png"></a></p>
<h3 id="Raft项目包含哪些模块？"><a href="#Raft项目包含哪些模块？" class="headerlink" title="Raft项目包含哪些模块？"></a>Raft项目包含哪些模块？</h3><h4 id="项目有多少行"><a href="#项目有多少行" class="headerlink" title="项目有多少行?"></a>项目有多少行?</h4><p>分析下整个项目大概是1W多行，并不是很大，代码注释非常齐全，理解起来比较轻松。代码抽象得很好，非常值得学习。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">-&gt;</span><span class="bash"> % cloc ./</span></span><br><span class="line">      77 text files.</span><br><span class="line">      77 unique files.</span><br><span class="line">       8 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.90  T=0.09 s (814.1 files/s, 201614.7 lines/s)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Language                     files          blank        comment           code</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Go                              57           2207           2786          11864</span><br><span class="line">Markdown                         4            106              0            255</span><br><span class="line">YAML                             4             26             29            141</span><br><span class="line">XML                              4              0              0            108</span><br><span class="line">make                             1             10              2             33</span><br><span class="line">Bourne Shell                     1              3              3             10</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">SUM:                            71           2352           2820          12411</span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h4 id="从哪里开始？"><a href="#从哪里开始？" class="headerlink" title="从哪里开始？"></a>从哪里开始？</h4><p>首先，我们来看下<code>api.go/Raft</code>结构，表示的是一个Raft节点，最核心的数据结构。划分3大块</p>
<ol>
<li><p>NewRaft节点需要的信息：下图中标红点的，几大核心组成。下一篇我们从网络层开始详细分析。</p>
<blockquote>
<p>除了raftState，其他部分全是interface，模块抽象的很细致。</p>
</blockquote>
</li>
<li><p>Leader操作相关：整个Raft最核心的就是Leader的状态转换过程。我们后续也会对这一部分的实现做详细说明。</p>
</li>
<li><p>一些异步操作：这一块是嵌入在各个模块的实现中的。项目里面一些chan的使用也是值得学习的。</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/oO0Ein"><img src="https://s4.ax1x.com/2021/12/13/oO0Ein.png" alt="oO0Ein.png"></a></p>
<h4 id="新建Raft节点逻辑？"><a href="#新建Raft节点逻辑？" class="headerlink" title="新建Raft节点逻辑？"></a>新建Raft节点逻辑？</h4><ul>
<li><p>① 校验配置</p>
</li>
<li><p>② 获取当前任期，从StableStore中获取</p>
</li>
<li><p>③ 获取最近的日志号和具体Log，从LogStore中获取</p>
</li>
<li><p>④ 创建Buffer applyCh，用来应用Log到FSM。这里Future的应用可以学习下，后面写applyLog的时候可以详细分析。</p>
</li>
<li><p>⑤ 初始化Raft结构。</p>
</li>
<li><p>⑥ Set各种变量，这里可以研究下config是怎么实现线程安全的变更。</p>
</li>
<li><p>⑦ 尝试从备份中恢复，处理peer变更日志，eg：添加节点、删除节点。这里为啥只处理Peer变更信息，都已经将Log解析出来了，为啥不直接应用呢？</p>
</li>
<li><p>⑧ 给传输层注册心跳处理器。在这里初始化，而不是在goroutine里面处理，是为了避免队头阻塞。</p>
</li>
<li><p>⑨ 启动goroutine，如下启动了3个协程。</p>
<p><a href="https://imgtu.com/i/oOhDud"><img src="https://s4.ax1x.com/2021/12/13/oOhDud.png" alt="oOhDud.png"></a></p>
</li>
</ul>
<p>代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(conf *Config, fsm FSM, logs LogStore, stable StableStore, snaps SnapshotStore, trans Transport)</span> <span class="params">(*Raft, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ① 校验配置</span></span><br><span class="line">  <span class="keyword">if</span> err := ValidateConfig(conf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ② 获取当前任务，这里是从StableStore中获取</span></span><br><span class="line">  currentTerm, err := stable.GetUint64(keyCurrentTerm)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ③ 获取最近的日志号和具体Log，从LogStore中获取；</span></span><br><span class="line">  lastIndex, err := logs.LastIndex()</span><br><span class="line">  <span class="keyword">if</span> err = logs.GetLog(lastIndex, &amp;lastLog); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to get last log at index %d: %v&quot;</span>, lastIndex, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ④ 创建Buffer applyCh，用来应用Log到FSM。这里Future的应用可以学习下。</span></span><br><span class="line">  applyCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *logFuture)</span><br><span class="line">  <span class="keyword">if</span> conf.BatchApplyCh &#123;</span><br><span class="line">    applyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> *logFuture, conf.MaxAppendEntries)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⑤ 初始化Raft结构。</span></span><br><span class="line">  r := &amp;Raft&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⑥ Set各种变量，下面这一行的实现可以研究下，为啥不直接r.conf = conf</span></span><br><span class="line">  r.conf.Store(*conf)</span><br><span class="line">  r.setState(Follower)</span><br><span class="line">  r.setCurrentTerm(currentTerm)</span><br><span class="line">  r.setLastLog(lastLog.Index, lastLog.Term)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⑦ 尝试从备份中恢复，处理peer变更日志，eg：添加节点、删除节点. </span></span><br><span class="line">  <span class="keyword">if</span> err := r.restoreSnapshot(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  snapshotIndex, _ := r.getLastSnapshot()</span><br><span class="line">  <span class="keyword">for</span> index := snapshotIndex + <span class="number">1</span>; index &lt;= lastLog.Index; index++ &#123;</span><br><span class="line">    <span class="keyword">var</span> entry Log</span><br><span class="line">    <span class="keyword">if</span> err := r.logs.GetLog(index, &amp;entry); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := r.processConfigurationLogEntry(&amp;entry); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ⑧ 给传输层注册心跳处理器</span></span><br><span class="line">  trans.SetHeartbeatHandler(r.processHeartbeat)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⑨ 启动goroutine</span></span><br><span class="line">  r.goFunc(r.run)</span><br><span class="line">  r.goFunc(r.runFSM)</span><br><span class="line">  r.goFunc(r.runSnapshots)</span><br><span class="line">  <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此，我们就将Raft节点启动起来了</p>
<h4 id="技术点1：atomic-Value"><a href="#技术点1：atomic-Value" class="headerlink" title="技术点1：atomic.Value"></a>技术点1：atomic.Value</h4><p><img src="https://blog.betacat.io/image/golang-atomic-value/atomic-value-store.drawio.png" alt="atomic.Value Store 流程"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// conf这个变量会涉及到多个goroutine的并发修改&amp;读取。</span></span><br><span class="line"><span class="comment">// 为了保证读写的原子性，通常我们会加锁。但是加锁又有点过重了，为了更加高效的实现，使用了atomic。</span></span><br><span class="line">conf atomic.Value</span><br><span class="line">r.conf.Store(*conf)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 8个写routine + 1个读routine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAtomic</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  <span class="keyword">var</span> gloMy = my&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">        tmp := rand.Uint64() % <span class="number">100</span></span><br><span class="line">        gloMy.v1 = tmp</span><br><span class="line">        <span class="comment">// 在这两次操作之间就会产生中间状态，这个状态就很奇怪没有意义</span></span><br><span class="line">        gloMy.v2 = fmt.Sprintf(<span class="string">&quot;s%d&quot;</span>, tmp)</span><br><span class="line">      &#125;</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      t.Log(gloMy.v1, gloMy.v2)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=== RUN   TestAtomic</span><br><span class="line">    tmp_test.<span class="keyword">go</span>:<span class="number">33</span>: <span class="number">75</span> s64 <span class="comment">// 不合符预期，脏读了</span></span><br><span class="line">    tmp_test.<span class="keyword">go</span>:<span class="number">33</span>: <span class="number">63</span> s63</span><br><span class="line">    tmp_test.<span class="keyword">go</span>:<span class="number">33</span>: <span class="number">48</span> s48</span><br><span class="line">    tmp_test.<span class="keyword">go</span>:<span class="number">33</span>: <span class="number">5</span> s5</span><br><span class="line">    tmp_test.<span class="keyword">go</span>:<span class="number">33</span>: <span class="number">1</span> s1</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.betacat.io/post/golang-atomic-value-exploration/">推荐一篇文章</a> ：文中将atomic的来龙去脉都解释了一遍。</p>
<h4 id="技术点2：队头阻塞"><a href="#技术点2：队头阻塞" class="headerlink" title="技术点2：队头阻塞"></a>技术点2：队头阻塞</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这行的位置，在goroutine启动之前注册HeartbeatHandler处理器</span></span><br><span class="line">trans.SetHeartbeatHandler(r.processHeartbeat)</span><br></pre></td></tr></table></figure>



<h4 id="小小疑问❓"><a href="#小小疑问❓" class="headerlink" title="小小疑问❓"></a>小小疑问❓</h4><p>Q: 为啥要叫FSM，我的理解FSM不就是类似于MySQL这种可以应用Log的地方吗？总感觉用状态机命名怪怪的，容易误会。</p>
<p>Q: Config 和 Configuration的区别? Config里面都是单个Raft节点的配置，比如超时之类的；Configuration是Raft Cluster相关的信息，比如有几个节点之类的。</p>
<p>​           </p>
]]></content>
      <tags>
        <tag>raft</tag>
      </tags>
  </entry>
</search>
