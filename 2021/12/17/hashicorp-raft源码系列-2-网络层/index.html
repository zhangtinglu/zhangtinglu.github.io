<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangtinglu.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概述接着上面–导读，本篇讲解Transport传输层实现。 如下NewRaft函数的参数中，除了Config结构，其他都是以interface形式实现。 接下来几篇我们分别对这5类接口进行详细分析。 123func NewRaft(conf *Config, fsm FSM, logs LogStore, stable StableStore, snaps SnapshotStore, trans">
<meta property="og:type" content="article">
<meta property="og:title" content="hashicorp:raft源码系列(2)--网络层">
<meta property="og:url" content="https://zhangtinglu.github.io/2021/12/17/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-2-%E7%BD%91%E7%BB%9C%E5%B1%82/index.html">
<meta property="og:site_name" content="Moonshine&#39;s Blog">
<meta property="og:description" content="概述接着上面–导读，本篇讲解Transport传输层实现。 如下NewRaft函数的参数中，除了Config结构，其他都是以interface形式实现。 接下来几篇我们分别对这5类接口进行详细分析。 123func NewRaft(conf *Config, fsm FSM, logs LogStore, stable StableStore, snaps SnapshotStore, trans">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/14/ovlYo6.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/14/ovW3X4.md.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/16/T9BOV1.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/16/T9R9Hg.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/14/ovxupF.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/16/TCM7Us.md.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/16/TClAFs.md.png">
<meta property="article:published_time" content="2021-12-17T08:18:40.000Z">
<meta property="article:modified_time" content="2021-12-17T08:24:07.803Z">
<meta property="article:author" content="Moonshine">
<meta property="article:tag" content="raft">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s4.ax1x.com/2021/12/14/ovlYo6.png">

<link rel="canonical" href="https://zhangtinglu.github.io/2021/12/17/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-2-%E7%BD%91%E7%BB%9C%E5%B1%82/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>hashicorp:raft源码系列(2)--网络层 | Moonshine's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Moonshine's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Moonshine's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日拱一卒无有尽，功不唐捐终入海</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/archives/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangtinglu.github.io/2021/12/17/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-2-%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moonshine">
      <meta itemprop="description" content="風が吹いて葉が落ち、落ち葉は土壌の肥やしとなり土壌を肥えさせ、果物がゆっくりと着実に育つのです">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moonshine's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          hashicorp:raft源码系列(2)--网络层
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-17 16:18:40 / 修改时间：16:24:07" itemprop="dateCreated datePublished" datetime="2021-12-17T16:18:40+08:00">2021-12-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>接着上面–导读，本篇讲解Transport传输层实现。</p>
<p>如下NewRaft函数的参数中，除了Config结构，其他都是以interface形式实现。</p>
<p>接下来几篇我们分别对这5类接口进行详细分析。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(conf *Config, fsm FSM, logs LogStore, stable StableStore, snaps SnapshotStore, trans Transport)</span> <span class="params">(*Raft, error)</span></span> &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="传输层涉及哪些文件"><a href="#传输层涉及哪些文件" class="headerlink" title="传输层涉及哪些文件"></a>传输层涉及哪些文件</h4><ul>
<li><p>transport.go: 定义传输层接口，下图中的Transport Interface对象。</p>
</li>
<li><p>inmem_transport.go: 以内存的方式实现Transport接口，用于测试。</p>
</li>
<li><p>net_transport.go: 网络方式实现Transport接口。</p>
</li>
<li><p>tcp_transport.go: 以TCP的方式实现了NetworkTransport需要的SteamLayer。</p>
</li>
<li><p>command.go：这个文件里面定义了各种RPC request和response的结构，eg: AppendEntriesRequest、AppendEntriesResponse</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ovlYo6"><img src="https://s4.ax1x.com/2021/12/14/ovlYo6.png" alt="ovlYo6.png"></a></p>
</li>
</ul>
<p>总结，NetworkTransport和InmemTransport是对Transport层的具体实现，接下来我们对NetworkTransport进行详细分析。</p>
<h4 id="传输层具体是怎么实现的呢？"><a href="#传输层具体是怎么实现的呢？" class="headerlink" title="传输层具体是怎么实现的呢？"></a>传输层具体是怎么实现的呢？</h4><h5 id="从测试用例TestNetworkTransport-AppendEntries开始"><a href="#从测试用例TestNetworkTransport-AppendEntries开始" class="headerlink" title="从测试用例TestNetworkTransport_AppendEntries开始"></a>从测试用例TestNetworkTransport_AppendEntries开始</h5><p>测试用例一般能告诉我们怎么玩，而AppendEntries发送日志又是最常用的功能。因此，我们就从这里开始。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ovW3X4"><img src="https://s4.ax1x.com/2021/12/14/ovW3X4.md.png" alt="ovW3X4.md.png"></a></p>
<ol>
<li><p>初始化消费者(trans1)，这一步后面是要详细看的，所以我们标星。</p>
</li>
<li><p>启动消费者，监听rpcCh，也就是Consumer()返回的只读channel。🤔：rpc.Respond函数只是给respCh添加了一个元素，那谁来消费这个元素呢？</p>
</li>
<li><p>初始化生产者( trans2)，同样使用newTCPTransport实现。</p>
</li>
<li><p>调用AppendEntries消息给消费者trans1，这里直接就获取返回了。为啥看着就是同步返回的呢? 按理说网络调用一般都是异步返回吧。这个星标步骤，我们后面来详细分析。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNetworkTransport_AppendEntries</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, useAddrProvider := <span class="keyword">range</span> []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>&#125; &#123;</span><br><span class="line">		<span class="comment">// ①初始化trans1 -- 消费者</span></span><br><span class="line">		trans1, err := makeTransport(t, useAddrProvider, <span class="string">&quot;localhost:0&quot;</span>)</span><br><span class="line">		</span><br><span class="line">		rpcCh := trans1.Consumer()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 定义测试使用的RPC请求</span></span><br><span class="line">		args := AppendEntriesRequest&#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		resp := AppendEntriesResponse&#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ② 启动消费者监听 </span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> rpc := &lt;-rpcCh:</span><br><span class="line">				<span class="comment">// 获取消息然后返回，注意Respond函数只是给RPC对象的RespChan添加一个值，那么谁来消费这和chan呢</span></span><br><span class="line">				rpc.Respond(&amp;resp, <span class="literal">nil</span>)</span><br><span class="line">			...</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ③ 初始化生产者 trans2</span></span><br><span class="line">		trans2, err := makeTransport(t, useAddrProvider, <span class="keyword">string</span>(trans1.LocalAddr()))</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ④ 发送AppendEntries消息给trans1，这里直接就获取返回了。为啥看着就是同步返回的呢</span></span><br><span class="line">		<span class="keyword">if</span> err := trans2.AppendEntries(<span class="string">&quot;id1&quot;</span>, trans1.LocalAddr(), &amp;args, &amp;out); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.Fatalf(<span class="string">&quot;err: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="makeTransport实现分析"><a href="#makeTransport实现分析" class="headerlink" title="makeTransport实现分析"></a>makeTransport实现分析</h5><ol>
<li><p>先看下函数调用关系</p>
<p>newTCPTransport：就是tcp端口绑定，生成TCPStreamLayer(上面的类图中知道是NetworkTransport结构需要的成员)</p>
<p>NewNetworkTransportWithConfig：创建NetworkTransport对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   makeTransport</span><br><span class="line">   -&gt; NewTCPTransportWithConfig</span><br><span class="line">     -&gt; newTCPTransport <span class="comment">// 负责进行tcp端口绑定，生成TCPStreamLayer</span></span><br><span class="line">   		-&gt; NewNetworkTransportWithConfig <span class="comment">// 真正创建NetworkTransport对象</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> newTCPTransport</span><br><span class="line"></span><br><span class="line">   下面是newTCPTransport的实现，最后transportCreator就是网络层的创建器</span><br><span class="line"></span><br><span class="line">   <span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">   // ① 调用net库绑定tcp监听端口</span></span><br><span class="line"><span class="string">   list, err := net.Listen(&quot;tcp&quot;, bindAddr)</span></span><br><span class="line"><span class="string">   // ② 将TCPListener -&gt; TCPStreamLayer(上面的类图中NetworkTransport需要实现StreamLayer接口)</span></span><br><span class="line"><span class="string">   stream := &amp;TCPStreamLayer&#123;</span></span><br><span class="line"><span class="string">   		advertise: advertise,</span></span><br><span class="line"><span class="string">   		listener:  list.(*net.TCPListener),</span></span><br><span class="line"><span class="string">   	&#125;</span></span><br><span class="line"><span class="string">   // ③ 将上面的 TCPStreamLayer-&gt; NetworkTransport，调用 NewNetworkTransportWithConfig</span></span><br><span class="line"><span class="string">   trans := transportCreator(stream)</span></span><br></pre></td></tr></table></figure></li>
<li><p>newNetworkTransport</p>
<p>下面是创建网络层的代码，一个Acceptor专门用来accetor连接，每个新的连接都会创建一个协程进行处理。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/T9BOV1"><img src="https://s4.ax1x.com/2021/12/16/T9BOV1.png" alt="T9BOV1.png"></a></p>
<ul>
<li><p>Main线程调用trans.listen()启动监听协程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ① 将上面的config注入进来，主要是Stream</span></span><br><span class="line">trans := &amp;NetworkTransport&#123;</span><br><span class="line">		connPool:              <span class="built_in">make</span>(<span class="keyword">map</span>[ServerAddress][]*netConn),</span><br><span class="line">		consumeCh:             <span class="built_in">make</span>(<span class="keyword">chan</span> RPC),</span><br><span class="line">		logger:                config.Logger,</span><br><span class="line">		maxPool:               config.MaxPool,</span><br><span class="line">		shutdownCh:            <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		stream:                config.Stream,</span><br><span class="line">		timeout:               config.Timeout,</span><br><span class="line">		TimeoutScale:          DefaultTimeoutScale,</span><br><span class="line">		serverAddressProvider: config.ServerAddressProvider,</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// ② 设置Stream上下文</span></span><br><span class="line">trans.setupStreamContext()</span><br><span class="line"><span class="comment">// ③ 启动一个后台线程，专门来处理连接</span></span><br><span class="line"><span class="keyword">go</span> trans.listen()</span><br></pre></td></tr></table></figure></li>
<li><p>Acceptor监听新连接，并启动处理协程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">listen</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// ① 接收新连接，这个底层是epoll实现，</span></span><br><span class="line">		conn, err := n.stream.Accept()</span><br><span class="line">		<span class="comment">// ② 启动处理协程</span></span><br><span class="line">		<span class="keyword">go</span> n.handleConn(n.getStreamContext(), conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对连接进行处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">handleConn</span><span class="params">(connCtx context.Context, conn net.Conn)</span></span> &#123;</span><br><span class="line">	r := bufio.NewReaderSize(conn, connReceiveBufferSize)</span><br><span class="line">	w := bufio.NewWriter(conn)</span><br><span class="line">	dec := codec.NewDecoder(r, &amp;codec.MsgpackHandle&#123;&#125;)</span><br><span class="line">	enc := codec.NewEncoder(w, &amp;codec.MsgpackHandle&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ① 读数据 -- 解码 -- 处理 -- 编码</span></span><br><span class="line">		<span class="keyword">if</span> err := n.handleCommand(r, dec, enc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// ② 返回</span></span><br><span class="line">		<span class="keyword">if</span> err := w.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handleCommand是核心的处理逻辑，这里通过chan让用户使用的时候感觉是同步的。</p>
<ol>
<li><p>获取类型ReadByte，约定第一位表示的RPC类型，eg:AppendEntries RequestVote</p>
</li>
<li><p>定义respCh。</p>
</li>
<li><p>对不同类型的Request进行解码。</p>
</li>
<li><p>将解码出来的RPC消息放到消费channel中</p>
</li>
<li><p>等respCh返回处理后的结构</p>
</li>
<li><p>将结构进行编码。</p>
<p>下面是和别的协程进行交互的方式，实际上处理逻辑是外包出去进行处理的。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/T9R9Hg"><img src="https://s4.ax1x.com/2021/12/16/T9R9Hg.png" alt="T9R9Hg.png"></a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">handleCommand</span><span class="params">(r *bufio.Reader, dec *codec.Decoder, enc *codec.Encoder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	getTypeStart := time.Now()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ① 获取类型，约定第一位表示的RPC类型，eg:AppendEntries RequestVote</span></span><br><span class="line">	rpcType, err := r.ReadByte()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ② 定义respCh</span></span><br><span class="line">	respCh := <span class="built_in">make</span>(<span class="keyword">chan</span> RPCResponse, <span class="number">1</span>)</span><br><span class="line">	rpc := RPC&#123;</span><br><span class="line">		RespChan: respCh,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ③ 对不同类型的Request进行解码</span></span><br><span class="line">	<span class="keyword">switch</span> rpcType &#123;</span><br><span class="line">	<span class="keyword">case</span> rpcAppendEntries:</span><br><span class="line">		<span class="keyword">var</span> req AppendEntriesRequest</span><br><span class="line">		<span class="keyword">if</span> err := dec.Decode(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		rpc.Command = &amp;req</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> rpcRequestVote:</span><br><span class="line">		<span class="keyword">var</span> req RequestVoteRequest</span><br><span class="line">		<span class="keyword">if</span> err := dec.Decode(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		rpc.Command = &amp;req</span><br><span class="line">   ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ④ 将解码出来的灌到Raft.consumeCh</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> n.consumeCh &lt;- rpc:</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ⑤ 等结果，上面的consumeCh被Raft的runLeader之类的其他协程进行处理后，将结果塞会到respCh。</span></span><br><span class="line">RESP:</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> resp := &lt;-respCh:</span><br><span class="line">		<span class="comment">// ⑥ 对结果进行编码</span></span><br><span class="line">		<span class="keyword">if</span> err := enc.Encode(resp.Response); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="AppendEntries实现分析"><a href="#AppendEntries实现分析" class="headerlink" title="AppendEntries实现分析"></a>AppendEntries实现分析</h5><p>上面的传输层已经创建好了连接的处理器(消费者)，现在需要消息的生产者，AppendEntries就能充当这一角色。</p>
<p>需要网络交互的RequestVote、AppendEntries、TimeoutNow都是调用的genericRPC实现的，genericRPC是真正执行请求的函数。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ovxupF"><img src="https://s4.ax1x.com/2021/12/14/ovxupF.png" alt="ovxupF.png"></a></p>
<p>下面是一个genericRPC的流程：</p>
<p>① 从连接池获取连接对象，简单的维护了一个连接池。</p>
<p>② 在连接上发送RPC请求。</p>
<p>③ 解码Response，将conn返还连接池如果可以的话。</p>
<blockquote>
<p>注意：这里发送请求之后，同步获取Response。如果是短链接，为了高效就不会直接在这里等结果了。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NetworkTransport)</span> <span class="title">genericRPC</span><span class="params">(id ServerID, target ServerAddress, rpcType <span class="keyword">uint8</span>, args <span class="keyword">interface</span>&#123;&#125;, resp <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// ① 从连接池中获取连接，NetworkTransport维护了一个连接池</span></span><br><span class="line">	conn, err := n.getConnFromAddressProvider(id, target)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ② 发送RPC请求</span></span><br><span class="line">	<span class="keyword">if</span> err = sendRPC(conn, rpcType, args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ③ 解码Response，并且归还连接。注意：这里发送了请求之后，马上就解码Response了。想想我们的mysql客户端，(发消息,等结果），不可以一直发消息而不接收。</span></span><br><span class="line">	canReturn, err := decodeResponse(conn, resp)</span><br><span class="line">	<span class="keyword">if</span> canReturn &#123;</span><br><span class="line">		n.returnConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们对比看看InmemTransport.makeRPC方法来体会其中的不同，这边获取结果需要从respCh读取。那么，这个Response是谁塞进去respCh的呢，毕竟我们只是获取了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *InmemTransport)</span> <span class="title">makeRPC</span><span class="params">(target ServerAddress, args <span class="keyword">interface</span>&#123;&#125;, r io.Reader, timeout time.Duration)</span> <span class="params">(rpcResp RPCResponse, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义交互用的RPC对象</span></span><br><span class="line">  req := RPC&#123;</span><br><span class="line">		Command:  args,</span><br><span class="line">		Reader:   r,</span><br><span class="line">		RespChan: respCh,</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 发送消息，直接将构造出来的req灌到peer.consumerCh消费channel，本来就是内存中的对象。</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> peer.consumerCh &lt;- req:</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 等respCh结果，消费协程把RPC拿出来-处理-结果塞回到respCh。</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> rpcResp = &lt;-respCh:</span><br><span class="line">      <span class="keyword">if</span> rpcResp.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">         err = rpcResp.Error</span><br><span class="line">      &#125;</span><br><span class="line">     .... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：</p>
<p>1、上面的实现是一条一条的发，实际上为了高效，我们往往都是批处理的。</p>
<p>2、想RequestVote要给多个对象发投票消息，那么肯定不会发一个消息等一个结果，而是群发，然后处理结构。</p>
<h5 id="AppendEntriesPipeline实现"><a href="#AppendEntriesPipeline实现" class="headerlink" title="AppendEntriesPipeline实现"></a>AppendEntriesPipeline实现</h5><p>同样的我们从测试用例开始，看看批处理是怎么玩的。主要看看批处理和单条处理的区别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化AppendEntriesPipeline对象，启动协程处理 inprogressCh -&gt; doneCh</span></span><br><span class="line">pipeline, err := trans2.AppendEntriesPipeline(<span class="string">&quot;id1&quot;</span>, trans1.LocalAddr())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发10个消息，并且将RPC加入到inprogressCh</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  out := <span class="built_in">new</span>(AppendEntriesResponse)</span><br><span class="line">  <span class="keyword">if</span> _, err := pipeline.AppendEntries(&amp;args, out); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.Fatalf(<span class="string">&quot;err: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer()会返回doneCh，从doneCh获取数据，发了10个消息，所以需要获取10次结果</span></span><br><span class="line">respCh := pipeline.Consumer()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ready := &lt;-respCh:</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是发消息的时候  非pipeline VS pipeline的区别</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TCM7Us"><img src="https://s4.ax1x.com/2021/12/16/TCM7Us.md.png" alt="TCM7Us.md.png"></a></p>
<p>下面是解码消息的时候  非pipeline VS pipeline的区别，pipeline的decodeResponses方法是初始化AppendEntriesPipeline对象的时候就启动的协程。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TClAFs"><img src="https://s4.ax1x.com/2021/12/16/TClAFs.md.png" alt="TClAFs.md.png"></a></p>
<p>这里有一个❓疑问关于net.Conn的 A-&gt;B-&gt;A，这个过程在网络上是两边可以同时发送数据吗？为啥上面的非pipeline模式，send之后马上就可以decode消息了，conn这里帮我们做了什么。</p>
<p>批处理的整体实现就是，启动一个协程监控inprogress的任务。然后开发批量的发消息，比如一次发10条，然后inprogress协程被激活，开始处理。将处理的结果放到doneCh，最后用户从doneCh获取消息即可。</p>
<h5 id="RequestVote过程"><a href="#RequestVote过程" class="headerlink" title="RequestVote过程"></a>RequestVote过程</h5><p>上面我们分析了一对一pipeline发消息，下面我们来看看1:N，在集群里面给所有人发消息，并且处理结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">electSelf</span><span class="params">()</span> &lt;-<span class="title">chan</span> *<span class="title">voteResult</span></span> &#123;</span><br><span class="line">	<span class="comment">// ① 创建一个包含peers数量的respCh</span></span><br><span class="line">	respCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *voteResult, <span class="built_in">len</span>(r.configurations.latest.Servers))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ② 并发发消息，然后将结果灌回到respCh。后面从respCh获取投票结果即可进行处理。</span></span><br><span class="line">	askPeer := <span class="function"><span class="keyword">func</span><span class="params">(peer Server)</span></span> &#123;</span><br><span class="line">		r.goFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			resp := &amp;voteResult&#123;voterID: peer.ID&#125;</span><br><span class="line">			err := r.trans.RequestVote(peer.ID, peer.Address, req, &amp;resp.RequestVoteResponse)</span><br><span class="line">			... </span><br><span class="line">			respCh &lt;- resp</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> respCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结🤔"><a href="#总结🤔" class="headerlink" title="总结🤔"></a>总结🤔</h4><p>网络是一个很复杂的模块，后续可以看看比较经典的Redis、Nginx这些优秀组件的实现。</p>
<p>ProxySQL：惊群效应思考</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/raft/" rel="tag"># raft</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/17/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-1-%E5%AF%BC%E8%AF%BB/" rel="prev" title="hashicorp:raft源码系列(1)--导读">
      <i class="fa fa-chevron-left"></i> hashicorp:raft源码系列(1)--导读
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/17/hashicorp-raft%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-3-%E5%AD%98%E5%82%A8%E5%B1%82/" rel="next" title="hashicorp:raft源码系列(3)--存储层">
      hashicorp:raft源码系列(3)--存储层 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E6%B6%89%E5%8F%8A%E5%93%AA%E4%BA%9B%E6%96%87%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">传输层涉及哪些文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">传输层具体是怎么实现的呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8BTestNetworkTransport-AppendEntries%E5%BC%80%E5%A7%8B"><span class="nav-number">3.1.</span> <span class="nav-text">从测试用例TestNetworkTransport_AppendEntries开始</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#makeTransport%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="nav-number">3.2.</span> <span class="nav-text">makeTransport实现分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AppendEntries%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="nav-number">3.3.</span> <span class="nav-text">AppendEntries实现分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AppendEntriesPipeline%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.4.</span> <span class="nav-text">AppendEntriesPipeline实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RequestVote%E8%BF%87%E7%A8%8B"><span class="nav-number">3.5.</span> <span class="nav-text">RequestVote过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%F0%9F%A4%94"><span class="nav-number">4.</span> <span class="nav-text">总结🤔</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Moonshine</p>
  <div class="site-description" itemprop="description">風が吹いて葉が落ち、落ち葉は土壌の肥やしとなり土壌を肥えさせ、果物がゆっくりと着実に育つのです</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Moonshine</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
